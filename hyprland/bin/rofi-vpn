#!/usr/bin/env bash

# ==============================================================================
# CONFIGURATION
# ==============================================================================

# Script version
VERSION="2.0"

# Help message
show_help() {
    cat << EOF
VPN Manager - WireGuard Connection Manager

USAGE:
    rofi-vpn [CONNECTION_NAME] [OPTIONS]

ARGUMENTS:
    CONNECTION_NAME    Optional. Name of VPN connection to connect/toggle.
                      If provided, skips Rofi menu and directly connects/toggles.

OPTIONS:
    -h, --help        Show this help message and exit
    -v, --version     Show version information and exit

EXAMPLES:
    rofi-vpn                    # Open Rofi menu to select VPN
    rofi-vpn US-VPN             # Connect/toggle US-VPN directly
    rofi-vpn --help             # Show help message

NOTES:
    - If CONNECTION_NAME matches the active VPN, it will disconnect
    - If CONNECTION_NAME is different, it will connect (disconnecting active VPN first)
    - Notifications are sent for all actions (if dunstify is available)
EOF
}

# Parse command line arguments
DIRECT_CONNECTION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "rofi-vpn version $VERSION"
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information." >&2
            exit 1
            ;;
        *)
            # First non-flag argument is treated as connection name
            if [ -z "$DIRECT_CONNECTION" ]; then
                DIRECT_CONNECTION="$1"
            fi
            shift
            ;;
    esac
done

# Rofi Theme Path (Matches your wallpaper script)
ROFI_THEME="$HOME/.config/rofi/launchers/type-2/style-1.rasi"

# Fallback icons (used when country code cannot be extracted)
ICON_CONNECTED="security-high"     # Or "network-vpn-acquired"
ICON_DISCONNECTED="network-vpn"    # Or "network-vpn"

# Status emojis/icons
CHECKMARK_EMOJI="ó°— "                # Checkmark for connected VPNs
LOCK_EMOJI="ðŸ”’"                     # Lock icon for disconnected VPNs

# Flag icon options (choose one method):
# 
# Option 1: Use emoji flags (default, no setup needed)
#   - Works out of the box, but may not render in all Rofi themes
#   - Set USE_EMOJI_FLAGS=true
USE_EMOJI_FLAGS=true

# Option 2: Use local flag image files
#   - Most reliable display, requires manual setup
#   - Set FLAG_DIR to a directory containing flag PNG files named as country codes (e.g., us.png, nl.png)
#   - You can download flags from: https://flagcdn.com/ or https://github.com/lipis/flag-icons
FLAG_DIR=""

# Option 3: Download flag images from remote URL and cache locally (RECOMMENDED)
#   - Automatic setup, reliable display, flags cached locally after first download
#   - Set FLAG_URL_BASE to enable (e.g., "https://flagcdn.com/w40/" or "https://raw.githubusercontent.com/lipis/flag-icons/main/flags/1x1/")
#   - Flags will be cached in ~/.cache/rofi-vpn/flags/
#   - Example: FLAG_URL_BASE="https://flagcdn.com/w40/" (40px width flags)
FLAG_URL_BASE="https://flagcdn.com/w80/"
FLAG_CACHE_DIR="$HOME/.cache/rofi-vpn/flags"

# Fixed Notification ID (Different from wallpaper script to avoid conflict)
NOTIF_ID=992022

# ==============================================================================
# FUNCTIONS
# ==============================================================================

# Extract country code from VPN name (optimized, no errors)
# Handles formats like: "US-VPN", "VPN-US", "US", "us-vpn", "US_Server", etc.
extract_country_code() {
    local vpn_name="$1"
    
    # Return early if empty
    [ -z "$vpn_name" ] && return 1
    
    # Try patterns in order of likelihood:
    # 1. Two uppercase letters at start: "US-VPN", "US_Server", "US"
    if [[ "$vpn_name" =~ ^([A-Z]{2})([-_]|$) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi
    
    # 2. Two uppercase letters after dash/underscore: "VPN-US", "Server-US"
    if [[ "$vpn_name" =~ [-_]([A-Z]{2})([-_]|$) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi
    
    # 3. Two uppercase letters anywhere (less reliable but catches edge cases)
    if [[ "$vpn_name" =~ ([A-Z]{2}) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi
    
    # 4. Try lowercase versions and convert to uppercase
    if [[ "$vpn_name" =~ ^([a-z]{2})([-_]|$) ]]; then
        echo "${BASH_REMATCH[1]^^}"
        return 0
    fi
    
    if [[ "$vpn_name" =~ [-_]([a-z]{2})([-_]|$) ]]; then
        echo "${BASH_REMATCH[1]^^}"
        return 0
    fi
    
    if [[ "$vpn_name" =~ ([a-z]{2}) ]]; then
        echo "${BASH_REMATCH[1]^^}"
        return 0
    fi
    
    return 1
}

# Convert 2-letter country code to Unicode emoji flag
# Example: "US" -> ðŸ‡ºðŸ‡¸
country_code_to_flag_emoji() {
    local code="$1"
    
    # Validate input: must be exactly 2 characters and only letters
    if [ ${#code} -ne 2 ] || [[ ! "$code" =~ ^[A-Za-z]{2}$ ]]; then
        return 1
    fi
    
    # Convert to uppercase
    code="${code^^}"
    
    local first="${code:0:1}"
    local second="${code:1:1}"
    
    # Get ASCII value and convert to Unicode codepoint
    local first_ascii=$(printf '%d' "'$first" 2>/dev/null)
    local second_ascii=$(printf '%d' "'$second" 2>/dev/null)
    
    # Validate ASCII values (A=65, Z=90)
    if [ -z "$first_ascii" ] || [ -z "$second_ascii" ] || \
       [ "$first_ascii" -lt 65 ] || [ "$first_ascii" -gt 90 ] || \
       [ "$second_ascii" -lt 65 ] || [ "$second_ascii" -gt 90 ]; then
        return 1
    fi
    
    # Convert to regional indicator codepoints (A=65 -> U+1F1E6)
    local first_cp=$((0x1F1E6 + first_ascii - 65))
    local second_cp=$((0x1F1E6 + second_ascii - 65))
    
    # Output as emoji using printf with proper format
    # Use %08X to ensure 8-digit hex format required by \U
    printf "\\U%08X\\U%08X" "$first_cp" "$second_cp" 2>/dev/null || return 1
}

# Check if flag image is cached (non-blocking, instant)
check_flag_cache() {
    local country_code="$1"
    local country_lower="${country_code,,}"
    
    if [ -z "$FLAG_URL_BASE" ] || [ -z "$country_code" ]; then
        return 1
    fi
    
    local cache_file="$FLAG_CACHE_DIR/${country_lower}.png"
    
    # If already cached, return the path (fast file check)
    if [ -f "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    return 1
}

# Download flag image in background (non-blocking)
download_flag_image_async() {
    local country_code="$1"
    local country_lower="${country_code,,}"
    
    if [ -z "$FLAG_URL_BASE" ]; then
        return 1
    fi
    
    # Create cache directory if it doesn't exist
    mkdir -p "$FLAG_CACHE_DIR"
    
    local cache_file="$FLAG_CACHE_DIR/${country_lower}.png"
    
    # Skip if already cached or currently downloading
    if [ -f "$cache_file" ] || [ -f "${cache_file}.downloading" ]; then
        return 0
    fi
    
    # Create a lock file to prevent duplicate downloads
    touch "${cache_file}.downloading"
    
    # Download in background
    local url="${FLAG_URL_BASE}${country_lower}.png"
    (
        if command -v curl >/dev/null 2>&1; then
            curl -s -f -o "$cache_file" "$url" 2>/dev/null || rm -f "$cache_file"
        elif command -v wget >/dev/null 2>&1; then
            wget -q -O "$cache_file" "$url" 2>/dev/null || rm -f "$cache_file"
        fi
        # Remove lock file
        rm -f "${cache_file}.downloading"
    ) &
    
    return 0
}

# Download flag image synchronously (kept for backward compatibility, but not used in menu)
download_flag_image() {
    local country_code="$1"
    local country_lower="${country_code,,}"
    
    if [ -z "$FLAG_URL_BASE" ]; then
        return 1
    fi
    
    # Create cache directory if it doesn't exist
    mkdir -p "$FLAG_CACHE_DIR"
    
    local cache_file="$FLAG_CACHE_DIR/${country_lower}.png"
    
    # If already cached, return the path
    if [ -f "$cache_file" ]; then
        echo "$cache_file"
        return 0
    fi
    
    # Try to download synchronously
    local url="${FLAG_URL_BASE}${country_lower}.png"
    if command -v curl >/dev/null 2>&1; then
        if curl -s -f -o "$cache_file" "$url" 2>/dev/null; then
            echo "$cache_file"
            return 0
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -q -O "$cache_file" "$url" 2>/dev/null; then
            echo "$cache_file"
            return 0
        fi
    fi
    
    return 1
}

# Get flag icon for VPN name (optimized: checks cache first, no blocking downloads)
# Returns flag emoji, image path, or fallback icon name
# Set third parameter to "true" to trigger async download (default: false, for menu building)
get_flag_icon() {
    local vpn_name="$1"
    local is_connected="${2:-false}"
    local trigger_download="${3:-false}"
    local fallback_icon="$ICON_DISCONNECTED"
    
    [ "$is_connected" = "true" ] && fallback_icon="$ICON_CONNECTED"
    
    # Try to extract country code
    local country_code=$(extract_country_code "$vpn_name" 2>/dev/null)
    
    if [ -n "$country_code" ]; then
        # Priority 1: Local flag directory
        if [ -n "$FLAG_DIR" ] && [ -f "$FLAG_DIR/${country_code,,}.png" ]; then
            echo "$FLAG_DIR/${country_code,,}.png"
            return 0
        fi
        
        # Priority 2: Check cache first (non-blocking, instant)
        if [ -n "$FLAG_URL_BASE" ]; then
            local cached_flag=$(check_flag_cache "$country_code" 2>/dev/null)
            if [ -n "$cached_flag" ]; then
                echo "$cached_flag"
                return 0
            fi
            
            # Only trigger download if explicitly requested (not during menu building)
            if [ "$trigger_download" = "true" ]; then
                download_flag_image_async "$country_code" >/dev/null 2>&1 &
            fi
        fi
        
        # Priority 3: Use emoji flag as fallback (if enabled)
        # This ensures Rofi opens immediately even if images aren't cached yet
        if [ "$USE_EMOJI_FLAGS" = "true" ]; then
            local flag_emoji=$(country_code_to_flag_emoji "$country_code" 2>/dev/null)
            if [ -n "$flag_emoji" ]; then
                echo "$flag_emoji"
                return 0
            fi
        fi
    fi
    
    # Fallback to default icon
    echo "$fallback_icon"
}

notify_load() {
    local message="$1"
    local vpn_name="${2:-}"
    local icon="network-vpn-acquiring"
    
    # Check if dunstify is available
    if ! command -v dunstify >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to get flag icon if VPN name is provided (only use image files, not emojis)
    if [ -n "$vpn_name" ]; then
        local flag_icon=$(get_flag_icon "$vpn_name" "false")
        # Use flag icon only if it's a file path (skip emojis)
        if [[ "$flag_icon" =~ ^/ ]] || [[ "$flag_icon" =~ \.(png|svg|jpg|jpeg)$ ]]; then
            icon="$flag_icon"
        fi
    fi
    
    dunstify " ï„²  VPN Manager" "$message" \
        -r "$NOTIF_ID" \
        -u "normal" \
        -i "$icon" \
        -t 0 2>/dev/null || true
}

notify_success() {
    local message="$1"
    local vpn_name="${2:-}"
    local icon="security-high"
    
    # Check if dunstify is available
    if ! command -v dunstify >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to get flag icon if VPN name is provided (only use image files, not emojis)
    if [ -n "$vpn_name" ]; then
        local flag_icon=$(get_flag_icon "$vpn_name" "true")
        # Use flag icon only if it's a file path (skip emojis)
        if [[ "$flag_icon" =~ ^/ ]] || [[ "$flag_icon" =~ \.(png|svg|jpg|jpeg)$ ]]; then
            icon="$flag_icon"
        fi
    fi
    
    dunstify " ï„²  VPN Manager" "$message" \
        -r "$NOTIF_ID" \
        -u "low" \
        -i "$icon" \
        -t 5000 2>/dev/null || true
}

notify_error() {
    local message="$1"
    local vpn_name="${2:-}"
    local icon="dialog-error"
    
    # Check if dunstify is available
    if ! command -v dunstify >/dev/null 2>&1; then
        echo "Error: $message" >&2
        return 0
    fi
    
    # Try to get flag icon if VPN name is provided (only use image files, not emojis)
    if [ -n "$vpn_name" ]; then
        local flag_icon=$(get_flag_icon "$vpn_name" "false")
        # Use flag icon only if it's a file path (skip emojis)
        if [[ "$flag_icon" =~ ^/ ]] || [[ "$flag_icon" =~ \.(png|svg|jpg|jpeg)$ ]]; then
            icon="$flag_icon"
        fi
    fi
    
    dunstify " ï„²  VPN Error" "$message" \
        -r "$NOTIF_ID" \
        -u "critical" \
        -i "$icon" \
        -t 5000 2>/dev/null || true
}

notify_off() {
    local vpn_name="${1:-}"
    local icon="network-vpn-no-route"
    
    # Check if dunstify is available
    if ! command -v dunstify >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to get flag icon if VPN name is provided (only use image files, not emojis)
    if [ -n "$vpn_name" ]; then
        local flag_icon=$(get_flag_icon "$vpn_name" "false")
        # Use flag icon only if it's a file path (skip emojis)
        if [[ "$flag_icon" =~ ^/ ]] || [[ "$flag_icon" =~ \.(png|svg|jpg|jpeg)$ ]]; then
            icon="$flag_icon"
        fi
    fi
    
    dunstify " ï„²  VPN Manager" "VPN Disconnected" \
        -r "$NOTIF_ID" \
        -u "low" \
        -i "$icon" \
        -t 3000 2>/dev/null || true
}

# Pre-download missing flags in background for all VPNs
prefetch_missing_flags() {
    # Only run if remote URL is enabled
    if [ -z "$FLAG_URL_BASE" ]; then
        return 0
    fi
    
    # Create cache directory if it doesn't exist
    mkdir -p "$FLAG_CACHE_DIR"
    
    # Extract country codes from all VPNs and download missing flags
    while IFS= read -r vpn_name; do
        local country_code=$(extract_country_code "$vpn_name")
        if [ -n "$country_code" ]; then
            # Trigger background download (function handles duplicates)
            download_flag_image_async "$country_code" >/dev/null 2>&1
        fi
    done <<< "$ALL_VPNS"
}

# ==============================================================================
# LOGIC
# ==============================================================================

# 1. Get the currently active WireGuard connection (if any)
ACTIVE_VPN=$(nmcli -t -f NAME,TYPE connection show --active | grep ":wireguard" | cut -d: -f1 | head -n1)

# 2. Get a list of ALL available WireGuard connections
# We use `nmcli` to list name and type, filter for wireguard, and just get the names
ALL_VPNS=$(nmcli -t -f NAME,TYPE connection show | grep ":wireguard" | cut -d: -f1 | sort)

if [ -z "$ALL_VPNS" ]; then
    notify_error "No WireGuard configurations found."
    exit 1
fi

# 2.5. Create cache directory early (if using remote flags)
# This prevents any delays during menu building
if [ -n "$FLAG_URL_BASE" ]; then
    mkdir -p "$FLAG_CACHE_DIR" 2>/dev/null
fi

# 2.6. Pre-fetch missing flags in background (completely non-blocking)
# This ensures flags are downloaded for next time, even for VPNs not shown in menu
# Run in subshell to detach completely
(prefetch_missing_flags >/dev/null 2>&1) &

# 3. Handle direct connection mode (skip Rofi menu)
if [ -n "$DIRECT_CONNECTION" ]; then
    TARGET="$DIRECT_CONNECTION"
    
    # Verify the connection exists
    if ! echo "$ALL_VPNS" | grep -q "^${TARGET}$"; then
        notify_error "VPN connection '$TARGET' not found."
        exit 1
    fi
    
    # Determine action: if selected VPN is the active one, disconnect; otherwise connect
    if [ -n "$ACTIVE_VPN" ] && [ "$TARGET" = "$ACTIVE_VPN" ]; then
        ACTION="disconnect"
    else
        ACTION="connect"
    fi
    
    # Jump to action handler (skip Rofi menu)
    # This will be handled below in the ACTION HANDLER section
else
    # Normal mode: show Rofi menu
    ACTION="menu"
fi

# 4. Show Rofi menu (only if not in direct connection mode)
if [ "$ACTION" = "menu" ]; then
    # Build the Rofi Menu List
    ROFI_LIST=""
    
    # Helper function to build menu entry with format: [FLAG_ICON] VPN_NAME [STATUS_EMOJI]
    build_menu_entry() {
        local vpn_name="$1"
        local is_connected="$2"
        local flag_icon="$3"
        
        # Build status indicator with Pango markup for styling
        local status_indicator
        if [ "$is_connected" = "true" ]; then
            # Green checkmark, bigger size using Pango markup
            status_indicator="<span foreground='#00ff00' size='large' weight='bold'>$CHECKMARK_EMOJI</span>"
        else
            status_indicator="$LOCK_EMOJI"
        fi
        
        # Build display text: VPN_NAME [STATUS_INDICATOR]
        local display_text="$vpn_name $status_indicator"
        
        # Check if flag_icon is a file path (image file)
        if [[ "$flag_icon" =~ ^/ ]] || [[ "$flag_icon" =~ \.(png|svg|jpg|jpeg)$ ]]; then
            # It's a file path - use as icon (big on left), display text as-is
            echo "$display_text\0icon\x1f$flag_icon"
        else
            # Check if it's an emoji flag (not a fallback icon name)
            if [[ "$flag_icon" != "$ICON_CONNECTED" ]] && [[ "$flag_icon" != "$ICON_DISCONNECTED" ]]; then
                # It's an emoji flag - use in icon field for size (may not render in all themes)
                # Also include in text as fallback/backup visibility
                echo "$flag_icon $display_text\0icon\x1f$flag_icon"
            else
                # It's a fallback icon name - use that as icon
                echo "$display_text\0icon\x1f$flag_icon"
            fi
        fi
    }
    
    # If there is an active connection, add it to the TOP with a special indicator
    if [ -n "$ACTIVE_VPN" ]; then
        # Get flag icon/emoji for active VPN
        flag_icon=$(get_flag_icon "$ACTIVE_VPN" "true")
        
        # Build entry: flag icon (big on left), VPN name, checkmark emoji
        ROFI_LIST+="$(build_menu_entry "$ACTIVE_VPN" "true" "$flag_icon")\n"
    fi
    
    # Add the rest of the available connections (skipping the active one to avoid duplicates)
    while IFS= read -r vpn_name; do
        if [ "$vpn_name" != "$ACTIVE_VPN" ]; then
            # Get flag icon/emoji for this VPN
            flag_icon=$(get_flag_icon "$vpn_name" "false")
            
            # Build entry: flag icon (big on left), VPN name, lock emoji
            ROFI_LIST+="$(build_menu_entry "$vpn_name" "false" "$flag_icon")\n"
        fi
    done <<< "$ALL_VPNS"
    
    # Open Rofi
    # -mesg shows current status at the bottom of the prompt
    CURRENT_STATUS_MSG="Status: ï‚œ Unsecured"
    [ -n "$ACTIVE_VPN" ] && CURRENT_STATUS_MSG="Status: ï€£ Connected to $ACTIVE_VPN"
    
    # Enable markup for Pango styling (needed for colored/bigger checkmark)
    SELECTED=$(echo -en "$ROFI_LIST" | rofi -dmenu -i -p "VPN " -mesg "$CURRENT_STATUS_MSG" -theme "$ROFI_THEME" -markup-rows)
    
    # Exit if user cancelled
    [ -z "$SELECTED" ] && exit 0
    
    # Parse selection: Format is "[FLAG_EMOJI] VPN_NAME [STATUS_INDICATOR]"
    # Remove flag emoji prefix, status indicator (with Pango markup), and any trailing whitespace
    # First remove Pango markup tags, then remove emojis and trailing spaces
    TARGET=$(echo "$SELECTED" | \
        sed 's/<[^>]*>//g' | \
        sed 's/^[^[:alnum:]]*//' | \
        sed 's/[[:space:]]\+[^[:space:]]*$//' | \
        sed 's/[[:space:]]*$//')
    
    # Determine action: if selected VPN is the active one, disconnect; otherwise connect
    if [ -n "$ACTIVE_VPN" ] && [ "$TARGET" = "$ACTIVE_VPN" ]; then
        ACTION="disconnect"
    else
        ACTION="connect"
    fi
fi

# ==============================================================================
# ACTION HANDLER
# ==============================================================================

# PERFORM ACTIONS
if [ "$ACTION" == "disconnect" ]; then
    notify_load "Disconnecting..." "$TARGET"
    nmcli connection down "$TARGET"
    
    if [ $? -eq 0 ]; then
        notify_off "$TARGET"
    else
        notify_error "Failed to disconnect." "$TARGET"
    fi

elif [ "$ACTION" == "connect" ]; then
    notify_load "Securing Connection..." "$TARGET"

    # A. If another VPN is active, kill it first (Clean Switch)
    if [ -n "$ACTIVE_VPN" ]; then
        nmcli connection down "$ACTIVE_VPN"
    fi

    # B. Connect to the new one
    OUTPUT=$(nmcli connection up "$TARGET" 2>&1)

    if [ $? -eq 0 ]; then
        notify_success "Connected to $TARGET" "$TARGET"
    else
        # If it failed, check why. 
        # Sometimes nmcli fails but it's just a timeout, check if active
        IS_UP=$(nmcli -t -f NAME,TYPE connection show --active | grep "$TARGET")
        if [ -n "$IS_UP" ]; then
            notify_success "Connected to $TARGET" "$TARGET"
        else
            notify_error "Connection Failed: $OUTPUT" "$TARGET"
        fi
    fi
fi