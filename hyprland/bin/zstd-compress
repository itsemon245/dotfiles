#!/usr/bin/env bash

# --- 1. SETUP & TRAP (Handle Ctrl+C) ---

TARGET="$1"
OPT_OUTPUT="$2"

# Function to handle User Abort (Ctrl+C)
handle_abort() {
    echo -e "\n\nüõë ABORTED BY USER (Ctrl+C)"
    echo "Cleaning up..."

    # Kill background jobs
    jobs -p | xargs -r kill

    # Remove the partial archive using the global variable
    if [ -n "$ARCHIVE_FULL_PATH" ] && [ -f "$ARCHIVE_FULL_PATH" ]; then
        rm -f "$ARCHIVE_FULL_PATH"
        echo "Removed partial file: $ARCHIVE_FULL_PATH"
    fi

    notify-send "Compression Cancelled" "Operation aborted by user." -u normal -i dialog-warning
    exit 130
}

trap handle_abort SIGINT

# --- 2. INPUT CHECKS & PATH RESOLUTION ---

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_file_or_folder> [optional_output_name]"
    read -n 1 -s -r -p "Press any key to exit..."
    exit 1
fi

# 1. Resolve Input Paths
if [ ! -e "$TARGET" ]; then
    echo "Error: Target not found: $TARGET"
    read -n 1 -s -r -p "Press any key to exit..."
    exit 1
fi
TARGET_PATH=$(realpath "$TARGET")
PARENT_DIR=$(dirname "$TARGET_PATH")
ITEM_NAME=$(basename "$TARGET_PATH")

# 2. Resolve Output Path (The logic you requested)
if [ -n "$OPT_OUTPUT" ]; then
    # Check if user added extension, if not, append it
    if [[ "$OPT_OUTPUT" != *.tar.zst ]]; then
        OPT_OUTPUT="${OPT_OUTPUT}.tar.zst"
    fi
    # Resolve absolute path (realpath -m allows non-existent files)
    ARCHIVE_FULL_PATH=$(realpath -m "$OPT_OUTPUT")
else
    # Default: Same folder as input, name = foldername.tar.zst
    ARCHIVE_FULL_PATH="${PARENT_DIR}/${ITEM_NAME}.tar.zst"
fi

# Ensure output directory exists
OUTPUT_DIR=$(dirname "$ARCHIVE_FULL_PATH")
if [ ! -d "$OUTPUT_DIR" ]; then
    echo "Error: Output directory does not exist: $OUTPUT_DIR"
    read -n 1 -s -r -p "Press any key to exit..."
    exit 1
fi

# Calculate Size (for PV)
echo "Calculating size of: $ITEM_NAME"
# We pause to calc size before changing dir
if [ -d "$TARGET_PATH" ]; then
    TOTAL_SIZE=$(du -sb "$TARGET_PATH" | awk '{print $1}')
else
    TOTAL_SIZE=$(stat -c%s "$TARGET_PATH")
fi

# Change to source directory so tar stores relative paths correctly
cd "$PARENT_DIR" || exit 1

# --- 3. DETECT DISK & SET COMPRESSION ---

# We check the Destination Drive (OUTPUT_DIR) because that's the write bottleneck
DEVICE=$(findmnt -n -o SOURCE --target "$OUTPUT_DIR")

# Check if rotational (1=HDD, 0=SSD)
IS_ROTATIONAL=$(lsblk -d -n -o ROTA "$DEVICE" 2>/dev/null | head -n 1)

if [ "$IS_ROTATIONAL" == "1" ]; then
    # HDD DETECTED (Destination): Write speed is limited (~120MB/s).
    DISK_TYPE="HDD (Rotational)"
    ZSTD_LEVEL="-8"
    STRATEGY="Max Density for HDD"
else
    # SSD DETECTED (Destination): Write speed is fast.
    DISK_TYPE="SSD (Flash/Fast)"
    ZSTD_LEVEL="-4"
    STRATEGY="Max Speed/Efficiency"
fi

ZSTD_ARGS="-T0 $ZSTD_LEVEL --long"

# --- 4. DISPLAY INFO ---

clear
echo "==================================================="
echo "           SMART ZSTD ARCHIVER                     "
echo "==================================================="
echo " Input:      $ITEM_NAME"
echo " Output:     $(basename "$ARCHIVE_FULL_PATH")"
echo " Location:   $OUTPUT_DIR"
echo " Size:       $(numfmt --to=si --suffix=B $TOTAL_SIZE)"
echo "---------------------------------------------------"
echo " Target Disk:$DISK_TYPE"
echo " Strategy:   $STRATEGY"
echo " Settings:   Level $ZSTD_LEVEL | Long Distance | Threads: All"
echo "---------------------------------------------------"
echo " üí° TIP: Press 'Ctrl + C' to Abort at any time."
echo "==================================================="
echo ""

# --- 5. RUN COMPRESSION ---

set -o pipefail

# Note: We write to "$ARCHIVE_FULL_PATH" which is the absolute resolved path
tar -cf - "$ITEM_NAME" 2>/dev/null | \
pv -p -t -e -r -b --si -s "$TOTAL_SIZE" | \
zstd $ZSTD_ARGS > "$ARCHIVE_FULL_PATH"

STATUS=$?

echo ""
echo "==================================================="

# --- 6. FINISH HANDLING ---

if [ $STATUS -eq 0 ]; then
    # --- CALCULATE STATS ---
    ARCHIVE_SIZE=$(stat -c%s "$ARCHIVE_FULL_PATH")
    SAVED_BYTES=$((TOTAL_SIZE - ARCHIVE_SIZE))

    # Calculate percentage using awk for floating point math
    PERCENT=$(awk -v t="$TOTAL_SIZE" -v a="$ARCHIVE_SIZE" 'BEGIN { printf "%.2f", ((t-a)/t)*100 }')

    # Format for display
    H_ARCHIVE=$(numfmt --to=si --suffix=B "$ARCHIVE_SIZE")
    H_SAVED=$(numfmt --to=si --suffix=B "$SAVED_BYTES")

    echo "‚úÖ SUCCESS! Archive created successfully."
    echo ""
    echo "üìä COMPRESSION RESULTS:"
    echo "   Original Size:   $(numfmt --to=si --suffix=B $TOTAL_SIZE)"
    echo "   Final Size:      $H_ARCHIVE"
    echo "   Space Saved:     $H_SAVED ($PERCENT%)"

    # Updated Icon to generic package icon
    notify-send "Compression Success" "Saved $H_SAVED ($PERCENT%)\nArchive: $(basename "$ARCHIVE_FULL_PATH")" -i package-x-generic

    echo ""
    read -n 1 -s -r -p "Press ANY key to close window..."
else
    echo "‚ùå FAILED. Error code: $STATUS"

    [ -f "$ARCHIVE_FULL_PATH" ] && rm -f "$ARCHIVE_FULL_PATH"

    notify-send "Compression Failed" "Check terminal for error details" -u critical -i dialog-error

    echo ""
    read -n 1 -s -r -p "Press ANY key to close window..."
fi
