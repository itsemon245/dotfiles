#!/usr/bin/env bash

# Package manager wrapper that auto-detects distro and supports common operations

set -uo pipefail

# Colors (if colors.sh is available)
if [ -f "$(dirname "$0")/../../colors.sh" ]; then
    source "$(dirname "$0")/../../colors.sh"
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    NC='\033[0m' # No Color
fi

# Get config directory path (XDG_CONFIG_HOME or default to ~/.config)
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
CONFIG_DIR="$XDG_CONFIG_HOME/pocman"
TYPES_DIR="$CONFIG_DIR/types"

# Create config directories if they don't exist
mkdir -p "$CONFIG_DIR"
mkdir -p "$TYPES_DIR"

# Check if package exists in a type TOML file
package_in_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    if [ ! -f "$type_file" ]; then
        return 1
    fi
    
    # Check for exact package name, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Remove inline comments (everything after #)
        line="${line%%#*}"
        # Trim whitespace
        line=$(echo "$line" | xargs)
        # Skip empty lines, comment-only lines, and section headers
        [ -z "$line" ] && continue
        [[ "$line" =~ ^\[.*\]$ ]] && continue
        # Check if it matches the package name exactly
        [ "$line" = "$package" ] && return 0
    done < "$type_file"
    
    return 1
}

# Migrate packages from general.toml to a dedicated type file
# Called when creating a new dedicated type file for the first time
migrate_packages_from_general() {
    local type=$1
    local type_file="$TYPES_DIR/${type}.toml"
    local general_file="$TYPES_DIR/general.toml"
    
    # If general.toml doesn't exist, nothing to migrate
    [ ! -f "$general_file" ] && return 0
    
    # Read packages from general.toml for this type
    local packages_to_migrate=()
    local in_section=0
    local current_section=""
    
    while IFS= read -r line || [ -n "$line" ]; do
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if it's a section header
        if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
            current_section="${BASH_REMATCH[1]}"
            in_section=0
            if [ "$current_section" = "$type" ]; then
                in_section=1
            fi
        # If we're in the target section, collect package names
        elif [ $in_section -eq 1 ] && [ -n "$clean_line" ]; then
            packages_to_migrate+=("$clean_line")
        fi
    done < "$general_file"
    
    # If there are packages to migrate, add them to the type file
    if [ ${#packages_to_migrate[@]} -gt 0 ]; then
        for pkg in "${packages_to_migrate[@]}"; do
            # Add each package to the type file (skip if already exists)
            if ! package_in_type_file "$type" "$pkg"; then
                echo "$pkg" >> "$type_file"
            fi
        done
        
        # Remove the type section from general.toml
        local temp_file=$(mktemp)
        in_section=0
        current_section=""
        
        while IFS= read -r line || [ -n "$line" ]; do
            local original_line="$line"
            local clean_line="${line%%#*}"
            clean_line=$(echo "$clean_line" | xargs)
            
            # Check if it's a section header
            if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
                current_section="${BASH_REMATCH[1]}"
                in_section=0
                if [ "$current_section" = "$type" ]; then
                    in_section=1
                    # Skip this section header
                    continue
                else
                    echo "$original_line" >> "$temp_file"
                fi
            # Skip lines in the target section
            elif [ $in_section -eq 1 ]; then
                continue
            # Keep all other lines
            else
                echo "$original_line" >> "$temp_file"
            fi
        done < "$general_file"
        
        mv "$temp_file" "$general_file"
    fi
}

# Add package to a type TOML file
add_package_to_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    # Create directory if it doesn't exist
    mkdir -p "$TYPES_DIR"
    
    # Check if this is a new file being created (not a dedicated type)
    local is_new_file=false
    if [ ! -f "$type_file" ] && ! is_dedicated_type "$type"; then
        is_new_file=true
    fi
    
    # Create file with section header if it doesn't exist
    if [ ! -f "$type_file" ]; then
        echo "[$type]" > "$type_file"
        
        # If this is a new dedicated file (not cli/gaming/desktop), migrate packages from general.toml
        if [ "$is_new_file" = true ]; then
            migrate_packages_from_general "$type"
        fi
    fi
    
    # Check if package already exists
    if package_in_type_file "$type" "$package"; then
        return 0
    fi
    
    # Add package to file (after section header)
    local temp_file=$(mktemp)
    local section_found=0
    local inserted=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the section
        if [[ "$clean_line" =~ ^\[${type}\]$ ]]; then
            section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$type_file"
    
    # If section doesn't exist, add it at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "[$type]" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$type_file"
}

# Remove package from a type TOML file
remove_package_from_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    if [ ! -f "$type_file" ]; then
        return 0  # File doesn't exist, nothing to remove
    fi
    
    local temp_file=$(mktemp)
    local package_found=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        local package_name=$(echo "$clean_line" | xargs)
        
        # Check if we're entering any section
        if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Skip the package if it matches (ignoring comments)
        elif [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
            package_found=1
            # Don't echo this line (remove it)
            continue
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$type_file"
    
    mv "$temp_file" "$type_file"
    
    return $([ $package_found -eq 1 ] && echo 0 || echo 1)
}

# Remove package from all type files except the specified one
remove_package_from_other_types() {
    local exclude_type=$1
    local package=$2
    
    # Find all .toml files in types directory
    for type_file in "$TYPES_DIR"/*.toml; do
        [ ! -f "$type_file" ] && continue
        
        local filename=$(basename "$type_file" .toml)
        
        # Skip the exclude type
        [ "$filename" = "$exclude_type" ] && continue
        
        # Remove package from this type file
        remove_package_from_type_file "$filename" "$package" >/dev/null 2>&1
    done
    
    # Also check general.toml and remove from all sections except the exclude type
    local general_file="$TYPES_DIR/general.toml"
    if [ -f "$general_file" ]; then
        local temp_file=$(mktemp)
        local current_section=""
        local in_exclude_section=false
        
        while IFS= read -r line || [ -n "$line" ]; do
            local original_line="$line"
            local clean_line="${line%%#*}"
            clean_line=$(echo "$clean_line" | xargs)
            
            # Check if it's a section header
            if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
                current_section="${BASH_REMATCH[1]}"
                in_exclude_section=false
                if [ "$current_section" = "$exclude_type" ]; then
                    in_exclude_section=true
                fi
                echo "$original_line" >> "$temp_file"
            # Skip the package if it matches and we're not in the exclude section
            elif [ "$clean_line" = "$package" ] && [ -n "$clean_line" ] && [ "$in_exclude_section" = false ]; then
                # Don't echo this line (remove it)
                continue
            # Regular line - preserve it (including comments)
            else
                echo "$original_line" >> "$temp_file"
            fi
        done < "$general_file"
        
        mv "$temp_file" "$general_file"
    fi
}

# Check if a type should use a dedicated file (cli, gaming, desktop)
# These types always get their own files, never go in general.toml
is_dedicated_type() {
    local type=$1
    case "$type" in
        cli|gaming|desktop)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Check if a type file exists
type_file_exists() {
    local type=$1
    [ -f "$TYPES_DIR/${type}.toml" ]
}

# Add package to general.toml with specified type
add_package_to_general_toml() {
    local type=$1
    local package=$2
    local general_file="$TYPES_DIR/general.toml"
    
    # Create directory if it doesn't exist
    mkdir -p "$TYPES_DIR"
    
    # Create file if it doesn't exist
    if [ ! -f "$general_file" ]; then
        echo "# General type packages" > "$general_file"
    fi
    
    # Check if package already exists in this type section
    local temp_file=$(mktemp)
    local section_found=0
    local inserted=0
    local in_section=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the target section
        if [[ "$clean_line" =~ ^\[${type}\]$ ]]; then
            section_found=1
            in_section=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            in_section=0
            echo "$original_line" >> "$temp_file"
        # We're in the target section - check if package already exists
        elif [ $in_section -eq 1 ] && [ "$clean_line" = "$package" ]; then
            # Package already exists, skip adding it
            echo "$original_line" >> "$temp_file"
            inserted=1
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$general_file"
    
    # If section doesn't exist, add it at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "[$type]" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$general_file"
}

# Detect distribution
detect_distro() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            arch|archlinux|manjaro|endeavouros)
                echo "arch"
                ;;
            debian|ubuntu|pop)
                echo "debian"
                ;;
            fedora|rhel|centos|rocky|almalinux)
                echo "fedora"
                ;;
            *)
                echo "unknown"
                ;;
        esac
    else
        echo "unknown"
    fi
}

# Get TOML file path for distro
# Uses XDG_CONFIG_HOME/pocman/$distro.toml
# Creates directory if it doesn't exist
get_toml_path() {
    local distro=$1
    local toml_path="$CONFIG_DIR/${distro}.toml"
    
    # Ensure config directory exists
    mkdir -p "$CONFIG_DIR"
    
    echo "$toml_path"
}

# Check if package exists in a TOML file (ignores comments)
package_in_toml() {
    local distro=$1
    local package=$2
    local toml_file=$(get_toml_path "$distro")
    
    if [ ! -f "$toml_file" ]; then
        return 1
    fi
    
    # Check for exact package name, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Remove inline comments (everything after #)
        line="${line%%#*}"
        # Trim whitespace
        line=$(echo "$line" | xargs)
        # Skip empty lines and comment-only lines
        [ -z "$line" ] && continue
        # Check if it matches the package name exactly
        [ "$line" = "$package" ] && return 0
    done < "$toml_file"
    
    return 1
}

# Check if package exists in both distro TOML files
package_in_both_tomls() {
    local package=$1
    package_in_toml "arch" "$package" && package_in_toml "debian" "$package"
}

# Check if package exists in Arch repositories (pacman or AUR)
package_exists_arch() {
    local package=$1
    
    # Check pacman first
    if pacman -Si "$package" &>/dev/null; then
        return 0
    fi
    
    # Check AUR helpers
    if command -v yay &>/dev/null && yay -Si "$package" &>/dev/null; then
        return 0
    fi
    
    if command -v paru &>/dev/null && paru -Si "$package" &>/dev/null; then
        return 0
    fi
    
    return 1
}

# Check if package exists in Debian repositories (apt)
package_exists_debian() {
    local package=$1
    
    # Check apt cache
    if apt-cache show "$package" &>/dev/null; then
        return 0
    fi
    
    return 1
}

# Check if package exists in Fedora repositories (dnf)
package_exists_fedora() {
    local package=$1
    
    # Check dnf
    if dnf info "$package" &>/dev/null 2>&1; then
        return 0
    fi
    
    return 1
}

# Check if package exists in the other distro's package repositories
package_exists_other_distro() {
    local current_distro=$1
    local package=$2
    
    case "$current_distro" in
        arch)
            package_exists_debian "$package" || package_exists_fedora "$package"
            ;;
        debian)
            package_exists_arch "$package" || package_exists_fedora "$package"
            ;;
        fedora)
            package_exists_arch "$package" || package_exists_debian "$package"
            ;;
        *)
            return 1
            ;;
    esac
}

# Update TOML file with package (preserves comments)
# If explicit_type is provided, use it and manage type files accordingly
update_toml() {
    local distro=$1
    local package_manager=$2
    local package=$3
    local explicit_type=${4:-""}
    local create_type_file=${5:-"false"}
    local toml_file=$(get_toml_path "$distro")
    
    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$toml_file")"
    
    # Create file with sections if it doesn't exist
    if [ ! -f "$toml_file" ]; then
        case "$distro" in
            arch)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:pacman]

[cli:yay]

[cli:paru]

# Desktop packages
[desktop:pacman]

[desktop:yay]

[desktop:paru]

# Gaming packages
[gaming:pacman]

[gaming:yay]

[gaming:paru]
EOF
                ;;
            debian)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:apt]

# Desktop packages
[desktop:apt]

# Gaming packages
[gaming:apt]
EOF
                ;;
            fedora)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:dnf]

# Desktop packages
[desktop:dnf]

# Gaming packages
[gaming:dnf]
EOF
                ;;
        esac
    fi
    
    # Note: We don't return early if package exists - we need to move it to the correct section
    
    # Determine package category
    local category=$(get_package_category "$package" "$explicit_type")
    
    # If explicit type is provided, manage type files
    if [ -n "$explicit_type" ]; then
        # Remove package from other type files
        remove_package_from_other_types "$explicit_type" "$package"
        
        # Add package to the appropriate type file
        # cli, gaming, desktop always use dedicated files
        if is_dedicated_type "$explicit_type"; then
            add_package_to_type_file "$explicit_type" "$package"
        elif [ "$create_type_file" = "true" ]; then
            # --create-type-file flag: force creation of dedicated type file
            add_package_to_type_file "$explicit_type" "$package"
        elif type_file_exists "$explicit_type"; then
            add_package_to_type_file "$explicit_type" "$package"
        else
            # Type file doesn't exist and not a dedicated type, add to general.toml
            add_package_to_general_toml "$explicit_type" "$package"
        fi
    else
        # Auto-detect: add to type file
        # cli, gaming, desktop always use dedicated files
        if is_dedicated_type "$category"; then
            add_package_to_type_file "$category" "$package"
        elif type_file_exists "$category"; then
            add_package_to_type_file "$category" "$package"
        fi
    fi
    
    # Remove package from all sections in distro TOML before adding to new section
    # This ensures the package is only in one section
    if package_in_toml "$distro" "$package"; then
        # Remove from all sections first
        local temp_file_remove=$(mktemp)
        while IFS= read -r line || [ -n "$line" ]; do
            local original_line="$line"
            local clean_line="${line%%#*}"
            local package_name=$(echo "$clean_line" | xargs)
            
            # Check if we're entering any section
            if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
                echo "$original_line" >> "$temp_file_remove"
            # Skip the package if it matches (ignoring comments)
            elif [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
                # Don't echo this line (remove it)
                continue
            # Regular line - preserve it (including comments)
            else
                echo "$original_line" >> "$temp_file_remove"
            fi
        done < "$toml_file"
        mv "$temp_file_remove" "$toml_file"
    fi
    
    local target_section="[${category}:${package_manager}]"
    
    # Also check for legacy sections for backward compatibility
    local legacy_section="[${package_manager}]"
    
    local temp_file=$(mktemp)
    local target_section_found=0
    local legacy_section_found=0
    local inserted=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve the original line for comments
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the target section (new format)
        if [ "$clean_line" = "$target_section" ]; then
            target_section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering legacy section (backward compatibility)
        elif [ "$clean_line" = "$legacy_section" ]; then
            legacy_section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$toml_file"
    
    # If neither section exists, add the new format section at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "$target_section" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$toml_file"
}

# Update TOML files for all distros if package is common
# Checks if package exists in other distros' package repositories.
# If it exists in multiple distros' repositories, syncs to all relevant TOML files.
update_toml_sync() {
    local current_distro=$1
    local package_manager=$2
    local package=$3
    local explicit_type=${4:-""}
    local create_type_file=${5:-"false"}
    
    # Update current distro's TOML first
    update_toml "$current_distro" "$package_manager" "$package" "$explicit_type" "$create_type_file"
    
    # Check and sync to other distros if package exists there
    for other_distro in arch debian fedora; do
        # Skip current distro
        [ "$other_distro" = "$current_distro" ] && continue
        
        # Determine package manager for other distro
        case "$other_distro" in
            arch) other_pm="pacman" ;;
            debian) other_pm="apt" ;;
            fedora) other_pm="dnf" ;;
        esac
        
        # Check if package exists in this distro's repositories
        case "$other_distro" in
            arch)
                if package_exists_arch "$package"; then
                    echo -e "${CYAN}Package $package exists in arch repositories, updating arch.toml...${NC}"
                    update_toml "arch" "$other_pm" "$package" "$explicit_type" "$create_type_file"
                fi
                ;;
            debian)
                if package_exists_debian "$package"; then
                    echo -e "${CYAN}Package $package exists in debian repositories, updating debian.toml...${NC}"
                    update_toml "debian" "$other_pm" "$package" "$explicit_type" "$create_type_file"
                fi
                ;;
            fedora)
                if package_exists_fedora "$package"; then
                    echo -e "${CYAN}Package $package exists in fedora repositories, updating fedora.toml...${NC}"
                    update_toml "fedora" "$other_pm" "$package" "$explicit_type" "$create_type_file"
                fi
                ;;
        esac
    done
}

# Remove package from TOML file (checks all sections, preserves comments)
# Handles both new format [cli:pacman] and legacy format [pacman]
remove_from_toml() {
    local distro=$1
    local package_manager=$2
    local package=$3
    local toml_file=$(get_toml_path "$distro")
    
    if [ ! -f "$toml_file" ]; then
        return 0  # File doesn't exist, nothing to remove
    fi
    
    # Remove package from all sections where it appears
    local temp_file=$(mktemp)
    local in_section=0
    local package_found=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve the original line
        local original_line="$line"
        # Extract package name (remove inline comments and trim)
        local clean_line="${line%%#*}"
        local package_name=$(echo "$clean_line" | xargs)
        
        # Check if we're entering any section
        if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            in_section=1
            echo "$original_line" >> "$temp_file"
        # We're in a section - skip the package if it matches (ignoring comments)
        elif [ $in_section -eq 1 ] && [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
            package_found=1
            # Don't echo this line (remove it)
            continue
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$toml_file"
    
    mv "$temp_file" "$toml_file"
    
    if [ $package_found -eq 1 ]; then
        echo -e "${GREEN}Removed $package from ${distro}.toml${NC}"
    fi
}

# Remove package from TOML files for all distros if package is common
# Checks if package exists in other distros' package repositories.
# If it exists in multiple distros' repositories, removes from all relevant TOML files.
remove_from_toml_sync() {
    local current_distro=$1
    local package_manager=$2
    local package=$3
    
    # Remove from current distro's TOML first
    remove_from_toml "$current_distro" "$package_manager" "$package"
    
    # Check and remove from other distros if package exists there
    for other_distro in arch debian fedora; do
        # Skip current distro
        [ "$other_distro" = "$current_distro" ] && continue
        
        # Determine package manager for other distro
        case "$other_distro" in
            arch) other_pm="pacman" ;;
            debian) other_pm="apt" ;;
            fedora) other_pm="dnf" ;;
        esac
        
        # Check if package exists in this distro's repositories
        case "$other_distro" in
            arch)
                if package_exists_arch "$package"; then
                    echo -e "${CYAN}Package $package exists in arch repositories, removing from arch.toml...${NC}"
                    remove_from_toml "arch" "$other_pm" "$package"
                fi
                ;;
            debian)
                if package_exists_debian "$package"; then
                    echo -e "${CYAN}Package $package exists in debian repositories, removing from debian.toml...${NC}"
                    remove_from_toml "debian" "$other_pm" "$package"
                fi
                ;;
            fedora)
                if package_exists_fedora "$package"; then
                    echo -e "${CYAN}Package $package exists in fedora repositories, removing from fedora.toml...${NC}"
                    remove_from_toml "fedora" "$other_pm" "$package"
                fi
                ;;
        esac
    done
}

# Detect which package manager a package belongs to on Arch
# Returns: "pacman", "yay", "paru", or empty string if not found
detect_arch_package_manager() {
    local package=$1
    
    # Check pacman first
    if pacman -Si "$package" &>/dev/null; then
        echo "pacman"
        return 0
    fi
    
    # Check yay if available
    if command -v yay &>/dev/null && yay -Si "$package" &>/dev/null; then
        echo "yay"
        return 0
    fi
    
    # Check paru if available
    if command -v paru &>/dev/null && paru -Si "$package" &>/dev/null; then
        echo "paru"
        return 0
    fi
    
    # Not found
    return 1
}

# Install batch of packages on Arch with specific package manager
install_arch_batch() {
    local package_manager=$1
    local explicit_type=$2
    local create_type_file=$3
    shift 3
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        return 0
    fi
    
    case "$package_manager" in
        pacman)
            echo -e "${CYAN}Installing ${#packages[@]} package(s) via pacman: ${packages[*]}${NC}"
            if sudo pacman -S --noconfirm "${packages[@]}"; then
                # Update TOML for each package
                for package in "${packages[@]}"; do
                    update_toml_sync "arch" "pacman" "$package" "$explicit_type" "$create_type_file"
                done
                return 0
            else
                echo -e "${RED}Failed to install packages via pacman${NC}"
                return 1
            fi
            ;;
        yay)
            if ! command -v yay &>/dev/null; then
                echo -e "${RED}yay is not installed${NC}"
                return 1
            fi
            echo -e "${CYAN}Installing ${#packages[@]} package(s) via yay: ${packages[*]}${NC}"
            if yay -S --noconfirm "${packages[@]}"; then
                # Update TOML for each package
                for package in "${packages[@]}"; do
                    update_toml_sync "arch" "yay" "$package" "$explicit_type" "$create_type_file"
                done
                return 0
            else
                echo -e "${RED}Failed to install packages via yay${NC}"
                return 1
            fi
            ;;
        paru)
            if ! command -v paru &>/dev/null; then
                echo -e "${RED}paru is not installed${NC}"
                return 1
            fi
            echo -e "${CYAN}Installing ${#packages[@]} package(s) via paru: ${packages[*]}${NC}"
            if paru -S --noconfirm "${packages[@]}"; then
                # Update TOML for each package
                for package in "${packages[@]}"; do
                    update_toml_sync "arch" "paru" "$package" "$explicit_type" "$create_type_file"
                done
                return 0
            else
                echo -e "${RED}Failed to install packages via paru${NC}"
                return 1
            fi
            ;;
        *)
            echo -e "${RED}Unknown package manager: $package_manager${NC}"
            return 1
            ;;
    esac
}

# Install package on Arch with specific package manager (single package, kept for backward compatibility)
install_arch_with_pm() {
    local package=$1
    local package_manager=$2
    
    install_arch_batch "$package_manager" "" "$package"
}

# Install packages on Arch with intelligent batching
# Separates pacman and AUR packages, then batch installs each group
install_arch_batch_intelligent() {
    local explicit_type=$1
    local create_type_file=$2
    shift 2
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        return 0
    fi
    
    # Note: Don't show detected type for bulk operations - only for single package installs
    
    # Separate packages by package manager
    declare -a pacman_packages=()
    declare -a aur_packages=()
    declare -a not_found_packages=()
    
    # Determine which AUR helper to use (prefer yay over paru)
    local aur_helper=""
    if command -v yay &>/dev/null; then
        aur_helper="yay"
    elif command -v paru &>/dev/null; then
        aur_helper="paru"
    fi
    
    for package in "${packages[@]}"; do
        local pm=$(detect_arch_package_manager "$package")
        case "$pm" in
            pacman)
                pacman_packages+=("$package")
                ;;
            yay|paru)
                # Consolidate all AUR packages together
                aur_packages+=("$package")
                ;;
            *)
                not_found_packages+=("$package")
                ;;
        esac
    done
    
    local failed=false
    
    # Install pacman packages in batch
    if [ ${#pacman_packages[@]} -gt 0 ]; then
        echo -e "${CYAN}=== Installing ${#pacman_packages[@]} pacman package(s) ===${NC}"
        if ! install_arch_batch "pacman" "$explicit_type" "$create_type_file" "${pacman_packages[@]}"; then
            failed=true
        fi
    fi
    
    # Install AUR packages in batch (using preferred helper)
    if [ ${#aur_packages[@]} -gt 0 ]; then
        if [ -n "$aur_helper" ]; then
            echo -e "${CYAN}=== Installing ${#aur_packages[@]} AUR package(s) via $aur_helper ===${NC}"
            if ! install_arch_batch "$aur_helper" "$explicit_type" "$create_type_file" "${aur_packages[@]}"; then
                failed=true
            fi
        else
            echo -e "${RED}AUR packages found but neither yay nor paru is installed${NC}"
            echo -e "${YELLOW}Packages: ${aur_packages[*]}${NC}"
            failed=true
        fi
    fi
    
    # Report not found packages
    if [ ${#not_found_packages[@]} -gt 0 ]; then
        echo -e "${RED}Packages not found in any repository: ${not_found_packages[*]}${NC}"
        failed=true
    fi
    
    [ "$failed" = true ] && return 1
    return 0
}

# Install package on Arch (single package, kept for backward compatibility)
install_arch() {
    local package=$1
    local explicit_type=${2:-""}
    
    install_arch_batch_intelligent "$explicit_type" "false" "$package"
}

# Install batch of packages on Debian
install_debian_batch() {
    local explicit_type=$1
    local create_type_file=$2
    shift 2
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        return 0
    fi
    
    # Note: Don't show detected type for bulk operations - only for single package installs
    
    echo -e "${CYAN}Installing ${#packages[@]} package(s) via apt: ${packages[*]}${NC}"
    sudo apt update
    if sudo apt install -y "${packages[@]}"; then
        # Update TOML for each package
        for package in "${packages[@]}"; do
            update_toml_sync "debian" "apt" "$package" "$explicit_type" "$create_type_file"
        done
        return 0
    else
        return 1
    fi
}

# Install package on Debian (single package, kept for backward compatibility)
install_debian() {
    local package=$1
    local explicit_type=${2:-""}
    
    install_debian_batch "$explicit_type" "false" "$package"
}

# Install batch of packages on Fedora
install_fedora_batch() {
    local explicit_type=$1
    local create_type_file=$2
    shift 2
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        return 0
    fi
    
    # Note: Don't show detected type for bulk operations - only for single package installs
    
    echo -e "${CYAN}Installing ${#packages[@]} package(s) via dnf: ${packages[*]}${NC}"
    if sudo dnf install -y "${packages[@]}"; then
        # Update TOML for each package
        for package in "${packages[@]}"; do
            update_toml_sync "fedora" "dnf" "$package" "$explicit_type" "$create_type_file"
        done
        return 0
    else
        return 1
    fi
}

# Install package on Fedora (single package, kept for backward compatibility)
install_fedora() {
    local package=$1
    local explicit_type=${2:-""}
    
    install_fedora_batch "$explicit_type" "false" "$package"
}

# Remove package on Arch
remove_arch() {
    local package=$1
    local flags=${2:-"-Rns"}  # Default to -Rns (remove with dependencies and config)
    local package_manager=""
    
    # Try pacman first
    if pacman -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via pacman...${NC}"
        if sudo pacman $flags --noconfirm "$package"; then
            package_manager="pacman"
        else
            return 1
        fi
    # Try yay if available
    elif command -v yay &>/dev/null && yay -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via yay...${NC}"
        if yay $flags --noconfirm "$package"; then
            package_manager="yay"
        else
            return 1
        fi
    # Try paru if available
    elif command -v paru &>/dev/null && paru -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via paru...${NC}"
        if paru $flags --noconfirm "$package"; then
            package_manager="paru"
        else
            return 1
        fi
    else
        echo -e "${RED}Package $package not found or not installed${NC}"
        return 1
    fi
    
    # Remove from TOML if removal was successful
    if [ -n "$package_manager" ]; then
        remove_from_toml_sync "arch" "$package_manager" "$package"
    fi
    
    return 0
}

# Remove package on Debian
remove_debian() {
    local package=$1
    
    echo -e "${CYAN}Removing $package via apt...${NC}"
    if sudo apt remove -y "$package"; then
        # Remove from TOML if removal was successful
        remove_from_toml_sync "debian" "apt" "$package"
        return 0
    else
        return 1
    fi
}

# Remove package on Fedora
remove_fedora() {
    local package=$1
    
    echo -e "${CYAN}Removing $package via dnf...${NC}"
    if sudo dnf remove -y "$package"; then
        # Remove from TOML if removal was successful
        remove_from_toml_sync "fedora" "dnf" "$package"
        return 0
    else
        return 1
    fi
}

# Search packages on Arch
search_arch() {
    local query=$1
    
    echo -e "${CYAN}Searching pacman repositories for: $query${NC}"
    pacman -Ss "$query"
    
    if command -v yay &>/dev/null; then
        echo ""
        echo -e "${CYAN}Searching AUR (yay) for: $query${NC}"
        yay -Ss "$query"
    elif command -v paru &>/dev/null; then
        echo ""
        echo -e "${CYAN}Searching AUR (paru) for: $query${NC}"
        paru -Ss "$query"
    fi
}

# Search packages on Debian
search_debian() {
    local query=$1
    
    echo -e "${CYAN}Searching apt repositories for: $query${NC}"
    apt search "$query"
}

# Search packages on Fedora
search_fedora() {
    local query=$1
    
    echo -e "${CYAN}Searching dnf repositories for: $query${NC}"
    dnf search "$query"
}

# Update package lists and upgrade packages
update_packages() {
    local distro=$(detect_distro)
    
    case "$distro" in
        arch)
            echo -e "${CYAN}Updating package database and upgrading packages...${NC}"
            sudo pacman -Syu --noconfirm
            if command -v yay &>/dev/null; then
                echo ""
                echo -e "${CYAN}Updating AUR packages (yay)...${NC}"
                yay -Syu --noconfirm
            elif command -v paru &>/dev/null; then
                echo ""
                echo -e "${CYAN}Updating AUR packages (paru)...${NC}"
                paru -Syu --noconfirm
            fi
            ;;
        debian)
            echo -e "${CYAN}Updating package lists and upgrading packages...${NC}"
            sudo apt update && sudo apt upgrade -y
            ;;
        fedora)
            echo -e "${CYAN}Updating package database and upgrading packages...${NC}"
            sudo dnf update -y
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# Show package info
info_package() {
    local package=$1
    local distro=$(detect_distro)
    
    case "$distro" in
        arch)
            if pacman -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from pacman:${NC}"
                pacman -Si "$package"
            elif command -v yay &>/dev/null && yay -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from AUR (yay):${NC}"
                yay -Si "$package"
            elif command -v paru &>/dev/null && paru -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from AUR (paru):${NC}"
                paru -Si "$package"
            else
                echo -e "${RED}Package $package not found${NC}"
                return 1
            fi
            ;;
        debian)
            echo -e "${CYAN}Package info:${NC}"
            apt show "$package" 2>/dev/null || apt-cache show "$package" 2>/dev/null
            ;;
        fedora)
            echo -e "${CYAN}Package info:${NC}"
            dnf info "$package"
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# List installed packages
list_installed() {
    local distro=$(detect_distro)
    local query=${1:-""}
    
    case "$distro" in
        arch)
            if [ -n "$query" ]; then
                pacman -Q | grep -i "$query"
            else
                pacman -Q
            fi
            ;;
        debian)
            if [ -n "$query" ]; then
                dpkg -l | grep -i "$query"
            else
                dpkg -l
            fi
            ;;
        fedora)
            if [ -n "$query" ]; then
                dnf list installed | grep -i "$query"
            else
                dnf list installed
            fi
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# Determine package category
# Returns: "gaming", "cli", "desktop", or custom type
# If explicit_type is provided, use that instead of checking type files
get_package_category() {
    local package=$1
    local explicit_type=${2:-""}
    
    # If explicit type is provided, use it
    if [ -n "$explicit_type" ]; then
        echo "$explicit_type"
        return 0
    fi
    
    # Check type files in order: gaming, cli, desktop, then check general.toml
    if package_in_type_file "gaming" "$package"; then
        echo "gaming"
        return 0
    fi
    
    if package_in_type_file "cli" "$package"; then
        echo "cli"
        return 0
    fi
    
    if package_in_type_file "desktop" "$package"; then
        echo "desktop"
        return 0
    fi
    
    # Check general.toml for other types
    local general_file="$TYPES_DIR/general.toml"
    if [ -f "$general_file" ]; then
        local current_section=""
        while IFS= read -r line || [ -n "$line" ]; do
            local clean_line="${line%%#*}"
            clean_line=$(echo "$clean_line" | xargs)
            
            # Check if it's a section header
            if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
                current_section="${BASH_REMATCH[1]}"
            # Check if package matches
            elif [ "$clean_line" = "$package" ] && [ -n "$current_section" ]; then
                echo "$current_section"
                return 0
            fi
        done < "$general_file"
    fi
    
    # Default to desktop if not found in any type file
    echo "desktop"
}

# Parse comma-separated type list into array
# Usage: parse_type_list "cli,dev,gaming" -> array with cli dev gaming
parse_type_list() {
    local type_list=$1
    local IFS=','
    read -ra types <<< "$type_list"
    printf '%s\n' "${types[@]}" | tr '[:upper:]' '[:lower:]' | xargs -n1
}

# Check if a type is in the include/exclude lists
# Usage: should_include_type "cli" "cli,dev" "gaming"
# Returns 0 if type should be included, 1 if excluded
should_include_type() {
    local type=$1
    local only_types=$2  # comma-separated list of types to include (empty = all)
    local except_types=$3  # comma-separated list of types to exclude (empty = none)
    
    # If --except is specified and type is in the list, exclude it
    if [ -n "$except_types" ]; then
        local except_array=($(parse_type_list "$except_types"))
        for exclude_type in "${except_array[@]}"; do
            if [ "$type" = "$exclude_type" ]; then
                return 1  # Excluded
            fi
        done
    fi
    
    # If --only is specified, only include types in the list
    if [ -n "$only_types" ]; then
        local only_array=($(parse_type_list "$only_types"))
        for include_type in "${only_array[@]}"; do
            if [ "$type" = "$include_type" ]; then
                return 0  # Included
            fi
        done
        return 1  # Not in --only list, exclude
    fi
    
    # No filters, include all
    return 0
}

# Parse TOML file and extract packages by section
# Supports both old format [pacman] and new format [cli:pacman], [desktop:pacman], [gaming:pacman]
# only_types: comma-separated list of types to include (empty = all)
# except_types: comma-separated list of types to exclude (empty = none)
parse_toml_packages() {
    local toml_file=$1
    local only_types=${2:-""}
    local except_types=${3:-""}
    local section=""
    declare -A packages_by_section
    
    if [ ! -f "$toml_file" ]; then
        echo -e "${RED}TOML file not found: $toml_file${NC}"
        return 1
    fi
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve original line for comments
        local original_line="$line"
        
        # Remove inline comments (everything after #)
        local package_line="${line%%#*}"
        # Remove leading/trailing whitespace
        package_line=$(echo "$package_line" | xargs)
        
        # Skip empty lines and comment-only lines
        [ -z "$package_line" ] && continue
        
        # Check if it's a section header
        if [[ "$package_line" =~ ^\[.*\] ]]; then
            section="${package_line//[\[\]]/}"
            section=$(echo "$section" | xargs)
            packages_by_section["$section"]=""
        # It's a package name (non-empty line that's not a section header)
        elif [ -n "$section" ] && [ -n "$package_line" ]; then
            # Determine section category
            local section_type=""
            
            # Check section format: [cli:pacman], [desktop:pacman], [gaming:pacman], or legacy [pacman]
            if [[ "$section" =~ ^([^:]+): ]]; then
                # New format: extract type from section name
                section_type="${BASH_REMATCH[1]}"
            elif [[ ! "$section" =~ : ]]; then
                # Legacy format [pacman] - determine category from package name
                section_type=$(get_package_category "$package_line")
            fi
            
            # Skip packages based on --only and --except filters
            if ! should_include_type "$section_type" "$only_types" "$except_types"; then
                continue
            fi
            
            if [ -z "${packages_by_section[$section]}" ]; then
                packages_by_section["$section"]="$package_line"
            else
                packages_by_section["$section"]="${packages_by_section[$section]} $package_line"
            fi
        fi
    done < "$toml_file"
    
    # Output packages by section
    # For new format [cli:pacman], extract package manager for installation
    # Group packages by package manager (combining cli and desktop sections)
    declare -A packages_by_pm
    
    for section in "${!packages_by_section[@]}"; do
        local pm_name="$section"
        # Extract package manager from section name
        if [[ "$section" =~ : ]]; then
            # New format: [cli:pacman], [desktop:pacman], or [gaming:pacman] -> extract "pacman"
            pm_name="${section#*:}"
        fi
        # Combine packages from cli, desktop, and gaming sections for same PM
        if [[ -z "${packages_by_pm[$pm_name]:-}" ]]; then
            packages_by_pm["$pm_name"]="${packages_by_section[$section]}"
        else
            packages_by_pm["$pm_name"]="${packages_by_pm[$pm_name]} ${packages_by_section[$section]}"
        fi
    done
    
    # Output packages grouped by package manager
    for pm_name in "${!packages_by_pm[@]}"; do
        echo "${pm_name}:${packages_by_pm[$pm_name]}"
    done
}

# Install all packages from TOML file
install_all_from_toml() {
    local only_types=${1:-""}
    local except_types=${2:-""}
    local distro=$(detect_distro)
    local toml_file=$(get_toml_path "$distro")
    local failed_packages_file=$(mktemp)
    
    if [ ! -f "$toml_file" ]; then
        echo -e "${RED}TOML file not found: $toml_file${NC}"
        echo -e "${YELLOW}Run 'pocman -S <package-name>' to install packages first${NC}"
        return 1
    fi
    
    # Handle --all on non-Arch distros with confirmation
    if [ -z "$only_types" ] && [ -z "$except_types" ] && [ "$distro" != "arch" ]; then
        echo -e "${YELLOW}WARNING: You are about to install ALL packages from $toml_file${NC}"
        echo -e "${YELLOW}On $distro, this may include desktop and gaming packages.${NC}"
        echo ""
        
        if ! prompt_confirm "Do you want to install all packages?" "no"; then
            echo ""
            echo -e "${CYAN}Please specify which types to install (comma-separated):${NC}"
            echo -e "${CYAN}Example: cli,dev or cli${NC}"
            read -p "Types: " user_types
            user_types=$(echo "$user_types" | xargs | tr '[:upper:]' '[:lower:]')
            
            if [ -z "$user_types" ]; then
                echo -e "${YELLOW}No types specified. Aborting.${NC}"
                return 1
            fi
            
            only_types="$user_types"
            echo ""
        fi
    fi
    
    # Build filter message
    if [ -n "$only_types" ]; then
        echo -e "${CYAN}Installing packages of type(s): $only_types${NC}"
    elif [ -n "$except_types" ]; then
        echo -e "${CYAN}Installing all packages except type(s): $except_types${NC}"
    else
        echo -e "${CYAN}Installing all packages from $toml_file...${NC}"
    fi
    echo ""
    
    local parsed_packages
    parsed_packages=$(parse_toml_packages "$toml_file" "$only_types" "$except_types")
    
    case "$distro" in
        arch)
            # Install pacman packages first
            local pacman_pkgs=$(echo "$parsed_packages" | grep "^pacman:" | cut -d: -f2-)
            if [ -n "$pacman_pkgs" ]; then
                echo -e "${CYAN}=== Installing pacman packages ===${NC}"
                for package in $pacman_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "pacman"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            
            # Install yay packages
            local yay_pkgs=$(echo "$parsed_packages" | grep "^yay:" | cut -d: -f2-)
            if [ -n "$yay_pkgs" ] && command -v yay &>/dev/null; then
                echo ""
                echo -e "${CYAN}=== Installing yay packages ===${NC}"
                for package in $yay_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "yay"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            elif [ -n "$yay_pkgs" ]; then
                echo ""
                echo -e "${YELLOW}Warning: yay packages found but yay is not installed. Skipping yay packages.${NC}"
            fi
            
            # Install paru packages
            local paru_pkgs=$(echo "$parsed_packages" | grep "^paru:" | cut -d: -f2-)
            if [ -n "$paru_pkgs" ] && command -v paru &>/dev/null; then
                echo ""
                echo -e "${CYAN}=== Installing paru packages ===${NC}"
                for package in $paru_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "paru"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            elif [ -n "$paru_pkgs" ]; then
                echo ""
                echo -e "${YELLOW}Warning: paru packages found but paru is not installed. Skipping paru packages.${NC}"
            fi
            ;;
        debian)
            # Install apt packages
            local apt_pkgs=$(echo "$parsed_packages" | grep "^apt:" | cut -d: -f2-)
            if [ -n "$apt_pkgs" ]; then
                echo -e "${CYAN}=== Installing apt packages ===${NC}"
                echo -e "${CYAN}Updating package lists...${NC}"
                sudo apt update
                for package in $apt_pkgs; do
                    [ -z "$package" ] && continue
                    echo -e "${CYAN}Installing $package via apt...${NC}"
                    if ! sudo apt install -y "$package"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            ;;
        fedora)
            # Install dnf packages
            local dnf_pkgs=$(echo "$parsed_packages" | grep "^dnf:" | cut -d: -f2-)
            if [ -n "$dnf_pkgs" ]; then
                echo -e "${CYAN}=== Installing dnf packages ===${NC}"
                for package in $dnf_pkgs; do
                    [ -z "$package" ] && continue
                    echo -e "${CYAN}Installing $package via dnf...${NC}"
                    if ! sudo dnf install -y "$package"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            rm -f "$failed_packages_file"
            return 1
            ;;
    esac
    
    echo ""
    if [ -s "$failed_packages_file" ]; then
        local failed_list=$(cat "$failed_packages_file" | tr '\n' ' ')
        echo -e "${YELLOW}Warning: The following packages failed to install: ${failed_list}${NC}"
        rm -f "$failed_packages_file"
        return 1
    else
        echo -e "${GREEN}All packages installed successfully!${NC}"
        rm -f "$failed_packages_file"
        return 0
    fi
}

# Main install function
# Install batch of packages (intelligent batching)
install_packages_batch() {
    local explicit_type=$1
    local create_type_file=$2
    shift 2
    local packages=("$@")
    local distro=$(detect_distro)
    
    if [ ${#packages[@]} -eq 0 ]; then
        echo -e "${RED}Usage: pocman <package-name>...${NC}"
        exit 1
    fi
    
    # Show detected type only for single package installs (not bulk operations)
    if [ ${#packages[@]} -eq 1 ] && [ -z "$explicit_type" ]; then
        local detected_type=$(get_package_category "${packages[0]}" "")
        echo -e "${CYAN}Detected type: ${detected_type}${NC}"
    fi
    
    case "$distro" in
        arch)
            install_arch_batch_intelligent "$explicit_type" "$create_type_file" "${packages[@]}"
            ;;
        debian)
            install_debian_batch "$explicit_type" "$create_type_file" "${packages[@]}"
            ;;
        fedora)
            install_fedora_batch "$explicit_type" "$create_type_file" "${packages[@]}"
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            exit 1
            ;;
    esac
}

# Install package (single package, kept for backward compatibility)
install_package() {
    local package=$1
    local explicit_type=${2:-""}
    
    install_packages_batch "$package" "$explicit_type"
}

# Prompt for confirmation (returns 0 for yes, 1 for no)
# Usage: prompt_confirm "message" [default]
# default can be "yes" or "no" (defaults to "no")
prompt_confirm() {
    local message=$1
    local default=${2:-"no"}
    local prompt_text
    
    if [ "$default" = "yes" ]; then
        prompt_text="${message} [Y/n]: "
    else
        prompt_text="${message} [y/N]: "
    fi
    
    read -p "$prompt_text" response
    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
    
    if [ -z "$response" ]; then
        [ "$default" = "yes" ] && return 0 || return 1
    fi
    
    case "$response" in
        y|yes)
            return 0
            ;;
        n|no)
            return 1
            ;;
        *)
            # Invalid input, use default
            [ "$default" = "yes" ] && return 0 || return 1
            ;;
    esac
}

# Prompt for double confirmation with red warning (for destructive operations)
# Returns 0 if both confirmations are yes, 1 otherwise
prompt_double_confirm() {
    local message=$1
    
    echo -e "${RED}WARNING: This is a destructive operation!${NC}"
    echo -e "${RED}$message${NC}"
    echo ""
    
    if ! prompt_confirm "Are you sure you want to proceed?" "no"; then
        return 1
    fi
    
    echo ""
    if ! prompt_confirm "Please confirm again - this action cannot be undone" "no"; then
        return 1
    fi
    
    return 0
}

# Parse command/operation from arguments
# No longer defaults to install - requires explicit operation
parse_operation() {
    local first_arg=$1
    
    # Handle special flags and commands
    case "$first_arg" in
        --all|-a)
            echo "install_all"
            return 0
            ;;
        -R|-Rns|--remove|remove|uninstall)
            echo "remove"
            return 0
            ;;
        -Ss|--search|search)
            echo "search"
            return 0
            ;;
        -Syu|-Sy|--update|update|upgrade)
            echo "update"
            return 0
            ;;
        -Si|--info|info)
            echo "info"
            return 0
            ;;
        -Q|-Qe|-Qm|--list|list)
            echo "list"
            return 0
            ;;
        -S|--install|install)
            echo "install"
            return 0
            ;;
        -h|--help|help)
            echo "help"
            return 0
            ;;
    esac
    
    # Check for pacman-style flags (Arch)
    if [[ "$first_arg" =~ ^-R ]]; then
        echo "remove"
        return 0
    fi
    
    if [[ "$first_arg" =~ ^-Q ]]; then
        echo "list"
        return 0
    fi
    
    # No default - return unknown if no operation specified
    echo "unknown"
    return 1
}

# Show usage information
show_usage() {
    local script_name=$(basename "$0")
    printf "${CYAN}Pocman - The Ultimate Manager of Package Managers${NC}\n\n"
    printf "${CYAN}Usage:${NC}\n"
    printf "  ${script_name} [operation] [options] [packages...]\n\n"
    printf "${CYAN}Operations:${NC}\n"
    printf "  install, -S              Install packages\n"
    printf "  remove, -R, -Rns         Remove packages\n"
    printf "  search, -Ss              Search for packages\n"
    printf "  update, -Syu, upgrade    Update package lists and upgrade\n"
    printf "  info, -Si                Show package information\n"
    printf "  list, -Q                 List installed packages\n"
    printf "  help, -h, --help         Show this help message\n"
    printf "  --all, -a                Install/remove all packages from TOML file\n\n"
    printf "${CYAN}Options:${NC}\n"
    printf "  --type=TYPE, -t TYPE     Specify package type explicitly\n"
    printf "                           Example: --type=gaming, -t utils\n"
    printf "                           Works regardless of position in command line\n"
    printf "                           If type file doesn't exist, creates/updates general.toml\n"
    printf "                           Removes package from other type files if it exists\n\n"
    printf "  --only=TYPES             Install/remove only specified types (comma-separated)\n"
    printf "                           Example: --only=cli,dev\n"
    printf "                           Works with --all flag\n\n"
    printf "  --except=TYPES           Install/remove all types except specified (comma-separated)\n"
    printf "                           Example: --except=dev\n"
    printf "                           Works with --all flag\n\n"
    printf "  --create-type-file       Force creation of dedicated type file instead of using general.toml\n"
    printf "                           Example: pocman -S --type=dev --create-type-file ngrok\n"
    printf "                           Creates dev.toml and migrates existing dev packages from general.toml\n\n"
    printf "${CYAN}Examples:${NC}\n"
    printf "  ${CYAN}Install packages:${NC}\n"
    printf "  pocman -S git bat                    # Install packages (explicit)\n"
    printf "  pocman install git bat               # Install packages (subcommand)\n"
    printf "  pocman -S --type=gaming steam        # Install with explicit type\n"
    printf "  pocman install greenclip -t utils     # Install as utils type\n"
    printf "  pocman -S --type=dev --create-type-file ngrok  # Create dev.toml file\n\n"
    printf "  ${CYAN}Install from TOML:${NC}\n"
    printf "  pocman --all                          # Install all packages (prompts on non-Arch)\n"
    printf "  pocman --all --only=cli,dev          # Install only cli and dev packages\n"
    printf "  pocman --all --except=gaming         # Install all except gaming packages\n\n"
    printf "  ${CYAN}Remove packages:${NC}\n"
    printf "  pocman -Rns chromium                  # Remove package (Arch: pacman style)\n"
    printf "  pocman remove kitty                   # Remove package (Debian: apt style)\n"
    printf "  pocman remove --all --only=gaming    # Remove all gaming packages (with confirmation)\n\n"
    printf "  ${CYAN}Other operations:${NC}\n"
    printf "  pocman -Ss neovim                     # Search for packages (Arch)\n"
    printf "  pocman search neovim                  # Search for packages (Debian)\n"
    printf "  pocman -Syu                           # Update and upgrade (Arch)\n"
    printf "  pocman update                         # Update and upgrade (Debian)\n"
    printf "  pocman -Si chromium                   # Show package info (Arch)\n"
    printf "  pocman info chromium                  # Show package info (Debian)\n"
    printf "  pocman -Q                             # List installed packages (Arch)\n"
    printf "  pocman list                           # List installed packages (Debian)\n"
}

# Main argument parsing
if [ $# -eq 0 ]; then
    show_usage
    exit 1
fi

# Parse flags and remove them from arguments
# This works regardless of position in the command line
explicit_type=""
only_types=""
except_types=""
has_all_flag=false
create_type_file="false"
args=()
skip_next=false

# Convert arguments to array for easier iteration
declare -a all_args=("$@")

for i in "${!all_args[@]}"; do
    arg="${all_args[$i]}"
    # Get next argument if it exists
    if [ $((i+1)) -lt ${#all_args[@]} ]; then
        next_arg="${all_args[$((i+1))]}"
    else
        next_arg=""
    fi
    
    # Skip if we're processing the value after -t
    if [ "$skip_next" = true ]; then
        skip_next=false
        continue
    fi
    
    if [[ "$arg" =~ ^--type= ]]; then
        explicit_type="${arg#--type=}"
    elif [[ "$arg" =~ ^-t= ]]; then
        explicit_type="${arg#-t=}"
    elif [ "$arg" = "-t" ] && [ -n "$next_arg" ]; then
        # Handle -t as separate argument (next arg is the type)
        explicit_type="$next_arg"
        skip_next=true
    elif [[ "$arg" =~ ^--only= ]]; then
        only_types="${arg#--only=}"
    elif [[ "$arg" =~ ^--except= ]]; then
        except_types="${arg#--except=}"
    elif [ "$arg" = "--create-type-file" ]; then
        create_type_file="true"
        continue
    elif [ "$arg" = "--all" ] || [ "$arg" = "-a" ]; then
        # --all flag - don't add to args, mark that we saw it
        has_all_flag=true
        continue
    else
        args+=("$arg")
    fi
done

set -- "${args[@]}"

# If --all flag was present and no operation was specified, treat as install_all
if [ "$has_all_flag" = true ] && [ $# -eq 0 ]; then
    operation="install_all"
elif [ "$has_all_flag" = true ] && [ "$1" = "" ]; then
    operation="install_all"
else
    # Check if first arg exists before parsing
    if [ $# -gt 0 ] && [ -n "${1:-}" ]; then
        operation=$(parse_operation "$1")
    else
        operation="unknown"
    fi
fi

# Handle help operation
if [ "$operation" = "help" ]; then
    show_usage
    exit 0
fi

# Handle unknown operation
if [ "$operation" = "unknown" ]; then
    if [ $# -gt 0 ] && [ -n "${1:-}" ]; then
        echo -e "${RED}Error: Unknown operation '${1}'${NC}"
    else
        echo -e "${RED}Error: No operation specified${NC}"
    fi
    echo -e "${YELLOW}Run 'pocman help' for usage information${NC}"
    exit 1
fi

# Handle operations
case "$operation" in
    install_all)
        install_all_from_toml "$only_types" "$except_types"
        exit $?
        ;;
    remove)
        # Extract removal flags if present
        remove_flags="-Rns"
        if [[ "$1" =~ ^-R ]]; then
            remove_flags="$1"
            shift
        elif [[ "$1" =~ ^(--remove|remove|uninstall)$ ]]; then
            shift
        fi
        
        # Check if --all flag is present (check in remaining args)
        remove_all=false
        for arg in "$@"; do
            if [ "$arg" = "--all" ] || [ "$arg" = "-a" ]; then
                remove_all=true
                # Remove --all from args
                new_args=()
                for a in "$@"; do
                    [ "$a" != "--all" ] && [ "$a" != "-a" ] && new_args+=("$a")
                done
                set -- "${new_args[@]}"
                break
            fi
        done
        
        # Handle --all removal or removal with --only/--except (both trigger bulk removal)
        if [ "$remove_all" = true ] || [ -n "$only_types" ] || [ -n "$except_types" ]; then
            distro=$(detect_distro)
            toml_file=$(get_toml_path "$distro")
            
            if [ ! -f "$toml_file" ]; then
                echo -e "${RED}TOML file not found: $toml_file${NC}"
                exit 1
            fi
            
            # Build confirmation message
            confirm_msg="You are about to remove packages from $toml_file"
            if [ -n "$only_types" ]; then
                confirm_msg="$confirm_msg (only type(s): $only_types)"
            elif [ -n "$except_types" ]; then
                confirm_msg="$confirm_msg (except type(s): $except_types)"
            else
                confirm_msg="$confirm_msg (ALL packages)"
            fi
            
            # Double confirmation for removal (always required for bulk operations)
            if ! prompt_double_confirm "$confirm_msg"; then
                echo -e "${YELLOW}Removal cancelled.${NC}"
                exit 0
            fi
            
            # Parse packages from TOML
            parsed_packages=$(parse_toml_packages "$toml_file" "$only_types" "$except_types")
            failed_packages_file=$(mktemp)
            
            case "$distro" in
                arch)
                    # Remove pacman packages
                    pacman_pkgs=$(echo "$parsed_packages" | grep "^pacman:" | cut -d: -f2-)
                    if [ -n "$pacman_pkgs" ]; then
                        echo -e "${CYAN}=== Removing pacman packages ===${NC}"
                        for package in $pacman_pkgs; do
                            [ -z "$package" ] && continue
                            if ! remove_arch "$package" "$remove_flags"; then
                                echo "$package" >> "$failed_packages_file"
                            fi
                        done
                    fi
                    
                    # Remove yay packages
                    yay_pkgs=$(echo "$parsed_packages" | grep "^yay:" | cut -d: -f2-)
                    if [ -n "$yay_pkgs" ]; then
                        echo ""
                        echo -e "${CYAN}=== Removing yay packages ===${NC}"
                        for package in $yay_pkgs; do
                            [ -z "$package" ] && continue
                            if ! remove_arch "$package" "$remove_flags"; then
                                echo "$package" >> "$failed_packages_file"
                            fi
                        done
                    fi
                    
                    # Remove paru packages
                    paru_pkgs=$(echo "$parsed_packages" | grep "^paru:" | cut -d: -f2-)
                    if [ -n "$paru_pkgs" ]; then
                        echo ""
                        echo -e "${CYAN}=== Removing paru packages ===${NC}"
                        for package in $paru_pkgs; do
                            [ -z "$package" ] && continue
                            if ! remove_arch "$package" "$remove_flags"; then
                                echo "$package" >> "$failed_packages_file"
                            fi
                        done
                    fi
                    ;;
                debian)
                    apt_pkgs=$(echo "$parsed_packages" | grep "^apt:" | cut -d: -f2-)
                    if [ -n "$apt_pkgs" ]; then
                        echo -e "${CYAN}=== Removing apt packages ===${NC}"
                        for package in $apt_pkgs; do
                            [ -z "$package" ] && continue
                            if ! remove_debian "$package"; then
                                echo "$package" >> "$failed_packages_file"
                            fi
                        done
                    fi
                    ;;
                fedora)
                    dnf_pkgs=$(echo "$parsed_packages" | grep "^dnf:" | cut -d: -f2-)
                    if [ -n "$dnf_pkgs" ]; then
                        echo -e "${CYAN}=== Removing dnf packages ===${NC}"
                        for package in $dnf_pkgs; do
                            [ -z "$package" ] && continue
                            if ! remove_fedora "$package"; then
                                echo "$package" >> "$failed_packages_file"
                            fi
                        done
                    fi
                    ;;
                *)
                    echo -e "${RED}Unsupported distribution: $distro${NC}"
                    rm -f "$failed_packages_file"
                    exit 1
                    ;;
            esac
            
            echo ""
            if [ -s "$failed_packages_file" ]; then
                failed_list=$(cat "$failed_packages_file" | tr '\n' ' ')
                echo -e "${YELLOW}Warning: The following packages failed to remove: ${failed_list}${NC}"
                rm -f "$failed_packages_file"
                exit 1
            else
                echo -e "${GREEN}All packages removed successfully!${NC}"
                rm -f "$failed_packages_file"
            fi
            exit 0
        fi
        
        # Regular removal (specific packages)
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No packages specified for removal${NC}"
            exit 1
        fi
        
        distro=$(detect_distro)
        failed_packages=()
        for package in "$@"; do
            case "$distro" in
                arch)
                    if ! remove_arch "$package" "$remove_flags"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                debian)
                    if ! remove_debian "$package"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                fedora)
                    if ! remove_fedora "$package"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                *)
                    echo -e "${RED}Unsupported distribution: $distro${NC}"
                    exit 1
                    ;;
            esac
        done
        
        if [ ${#failed_packages[@]} -gt 0 ]; then
            echo -e "${YELLOW}Warning: Failed to remove: ${failed_packages[*]}${NC}"
            exit 1
        fi
        ;;
    search)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Ss|--search|search)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No search query specified${NC}"
            exit 1
        fi
        
        distro=$(detect_distro)
        for query in "$@"; do
            case "$distro" in
                arch)
                    search_arch "$query"
                    ;;
                debian)
                    search_debian "$query"
                    ;;
                fedora)
                    search_fedora "$query"
                    ;;
                *)
                    echo -e "${RED}Unsupported distribution: $distro${NC}"
                    exit 1
                    ;;
            esac
        done
        ;;
    update)
        update_packages
        exit $?
        ;;
    info)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Si|--info|info)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No package specified${NC}"
            exit 1
        fi
        
        for package in "$@"; do
            info_package "$package"
            echo ""
        done
        ;;
    list)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Q|-Qe|-Qm|--list|list)$ ]]; then
            shift
        fi
        list_installed "$@"
        ;;
    install)
        # Handle --all flag (check has_all_flag set during argument parsing)
        if [ "$has_all_flag" = true ]; then
            install_all_from_toml "$only_types" "$except_types"
            exit $?
        fi
        
        # Regular install (specific packages)
        # Check if first arg is the operation flag/command and remove it
        if [[ "$1" =~ ^(-S|--install|install)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No packages specified${NC}"
            echo -e "${YELLOW}Run 'pocman help' for usage information${NC}"
            exit 1
        fi
        
        # Batch install all packages at once (intelligent batching)
        if ! install_packages_batch "$explicit_type" "$create_type_file" "$@"; then
            echo -e "${RED}Error: Some packages failed to install${NC}"
            exit 1
        fi
        
        echo -e "${GREEN}All packages installed successfully!${NC}"
        ;;
    *)
        echo -e "${RED}Unknown operation: $operation${NC}"
        exit 1
        ;;
esac

