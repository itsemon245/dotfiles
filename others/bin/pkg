#!/usr/bin/env bash

# Package manager wrapper that auto-detects distro and supports common operations

set -uo pipefail

# Colors (if colors.sh is available)
if [ -f "$(dirname "$0")/../../colors.sh" ]; then
    source "$(dirname "$0")/../../colors.sh"
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    NC='\033[0m' # No Color
fi

# Get types directory path
SCRIPT_DIR="$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")"
TYPES_DIR="$HOME/dotfiles/others/packages/types"
if [ ! -d "$TYPES_DIR" ]; then
    # Fallback to script directory if types directory doesn't exist
    TYPES_DIR="$SCRIPT_DIR/../packages/types"
fi

# Check if package exists in a type TOML file
package_in_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    if [ ! -f "$type_file" ]; then
        return 1
    fi
    
    # Check for exact package name, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Remove inline comments (everything after #)
        line="${line%%#*}"
        # Trim whitespace
        line=$(echo "$line" | xargs)
        # Skip empty lines, comment-only lines, and section headers
        [ -z "$line" ] && continue
        [[ "$line" =~ ^\[.*\]$ ]] && continue
        # Check if it matches the package name exactly
        [ "$line" = "$package" ] && return 0
    done < "$type_file"
    
    return 1
}

# Add package to a type TOML file
add_package_to_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    # Create directory if it doesn't exist
    mkdir -p "$TYPES_DIR"
    
    # Create file with section header if it doesn't exist
    if [ ! -f "$type_file" ]; then
        echo "[$type]" > "$type_file"
    fi
    
    # Check if package already exists
    if package_in_type_file "$type" "$package"; then
        return 0
    fi
    
    # Add package to file (after section header)
    local temp_file=$(mktemp)
    local section_found=0
    local inserted=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the section
        if [[ "$clean_line" =~ ^\[${type}\]$ ]]; then
            section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$type_file"
    
    # If section doesn't exist, add it at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "[$type]" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$type_file"
}

# Remove package from a type TOML file
remove_package_from_type_file() {
    local type=$1
    local package=$2
    local type_file="$TYPES_DIR/${type}.toml"
    
    if [ ! -f "$type_file" ]; then
        return 0  # File doesn't exist, nothing to remove
    fi
    
    local temp_file=$(mktemp)
    local package_found=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        local package_name=$(echo "$clean_line" | xargs)
        
        # Check if we're entering any section
        if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Skip the package if it matches (ignoring comments)
        elif [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
            package_found=1
            # Don't echo this line (remove it)
            continue
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$type_file"
    
    mv "$temp_file" "$type_file"
    
    return $([ $package_found -eq 1 ] && echo 0 || echo 1)
}

# Remove package from all type files except the specified one
remove_package_from_other_types() {
    local exclude_type=$1
    local package=$2
    
    # Find all .toml files in types directory
    for type_file in "$TYPES_DIR"/*.toml; do
        [ ! -f "$type_file" ] && continue
        
        local filename=$(basename "$type_file" .toml)
        
        # Skip the exclude type
        [ "$filename" = "$exclude_type" ] && continue
        
        # Remove package from this type file
        remove_package_from_type_file "$filename" "$package" >/dev/null 2>&1
    done
    
    # Also check general.toml and remove from all sections except the exclude type
    local general_file="$TYPES_DIR/general.toml"
    if [ -f "$general_file" ]; then
        local temp_file=$(mktemp)
        local current_section=""
        local in_exclude_section=false
        
        while IFS= read -r line || [ -n "$line" ]; do
            local original_line="$line"
            local clean_line="${line%%#*}"
            clean_line=$(echo "$clean_line" | xargs)
            
            # Check if it's a section header
            if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
                current_section="${BASH_REMATCH[1]}"
                in_exclude_section=false
                if [ "$current_section" = "$exclude_type" ]; then
                    in_exclude_section=true
                fi
                echo "$original_line" >> "$temp_file"
            # Skip the package if it matches and we're not in the exclude section
            elif [ "$clean_line" = "$package" ] && [ -n "$clean_line" ] && [ "$in_exclude_section" = false ]; then
                # Don't echo this line (remove it)
                continue
            # Regular line - preserve it (including comments)
            else
                echo "$original_line" >> "$temp_file"
            fi
        done < "$general_file"
        
        mv "$temp_file" "$general_file"
    fi
}

# Check if a type file exists
type_file_exists() {
    local type=$1
    [ -f "$TYPES_DIR/${type}.toml" ]
}

# Add package to general.toml with specified type
add_package_to_general_toml() {
    local type=$1
    local package=$2
    local general_file="$TYPES_DIR/general.toml"
    
    # Create directory if it doesn't exist
    mkdir -p "$TYPES_DIR"
    
    # Create file if it doesn't exist
    if [ ! -f "$general_file" ]; then
        echo "# General type packages" > "$general_file"
    fi
    
    # Check if package already exists in this type section
    local temp_file=$(mktemp)
    local section_found=0
    local inserted=0
    local in_section=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the target section
        if [[ "$clean_line" =~ ^\[${type}\]$ ]]; then
            section_found=1
            in_section=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            in_section=0
            echo "$original_line" >> "$temp_file"
        # We're in the target section - check if package already exists
        elif [ $in_section -eq 1 ] && [ "$clean_line" = "$package" ]; then
            # Package already exists, skip adding it
            echo "$original_line" >> "$temp_file"
            inserted=1
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$general_file"
    
    # If section doesn't exist, add it at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "[$type]" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$general_file"
}

# Detect distribution
detect_distro() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            arch|archlinux|manjaro|endeavouros)
                echo "arch"
                ;;
            debian|ubuntu|pop)
                echo "debian"
                ;;
            fedora|rhel|centos|rocky|almalinux)
                echo "fedora"
                ;;
            *)
                echo "unknown"
                ;;
        esac
    else
        echo "unknown"
    fi
}

# Get TOML file path for distro
# First tries ~/packages/$distro.toml, then falls back to ~/dotfiles/others/packages/$distro.toml
# If neither exists, returns primary path for new file creation
get_toml_path() {
    local distro=$1
    local primary_path="$HOME/packages/${distro}.toml"
    local fallback_path="$HOME/dotfiles/others/packages/${distro}.toml"
    
    # Try primary path first
    if [ -f "$primary_path" ]; then
        echo "$primary_path"
        return 0
    fi
    
    # Try fallback path
    if [ -f "$fallback_path" ]; then
        echo "$fallback_path"
        return 0
    fi
    
    # Neither exists - return primary path for new file creation
    echo "$primary_path"
}

# Check if package exists in a TOML file (ignores comments)
package_in_toml() {
    local distro=$1
    local package=$2
    local toml_file=$(get_toml_path "$distro")
    
    if [ ! -f "$toml_file" ]; then
        return 1
    fi
    
    # Check for exact package name, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Remove inline comments (everything after #)
        line="${line%%#*}"
        # Trim whitespace
        line=$(echo "$line" | xargs)
        # Skip empty lines and comment-only lines
        [ -z "$line" ] && continue
        # Check if it matches the package name exactly
        [ "$line" = "$package" ] && return 0
    done < "$toml_file"
    
    return 1
}

# Check if package exists in both distro TOML files
package_in_both_tomls() {
    local package=$1
    package_in_toml "arch" "$package" && package_in_toml "debian" "$package"
}

# Check if package exists in Arch repositories (pacman or AUR)
package_exists_arch() {
    local package=$1
    
    # Check pacman first
    if pacman -Si "$package" &>/dev/null; then
        return 0
    fi
    
    # Check AUR helpers
    if command -v yay &>/dev/null && yay -Si "$package" &>/dev/null; then
        return 0
    fi
    
    if command -v paru &>/dev/null && paru -Si "$package" &>/dev/null; then
        return 0
    fi
    
    return 1
}

# Check if package exists in Debian repositories (apt)
package_exists_debian() {
    local package=$1
    
    # Check apt cache
    if apt-cache show "$package" &>/dev/null; then
        return 0
    fi
    
    return 1
}

# Check if package exists in Fedora repositories (dnf)
package_exists_fedora() {
    local package=$1
    
    # Check dnf
    if dnf info "$package" &>/dev/null 2>&1; then
        return 0
    fi
    
    return 1
}

# Check if package exists in the other distro's package repositories
package_exists_other_distro() {
    local current_distro=$1
    local package=$2
    
    case "$current_distro" in
        arch)
            package_exists_debian "$package" || package_exists_fedora "$package"
            ;;
        debian)
            package_exists_arch "$package" || package_exists_fedora "$package"
            ;;
        fedora)
            package_exists_arch "$package" || package_exists_debian "$package"
            ;;
        *)
            return 1
            ;;
    esac
}

# Update TOML file with package (preserves comments)
# If explicit_type is provided, use it and manage type files accordingly
update_toml() {
    local distro=$1
    local package_manager=$2
    local package=$3
    local explicit_type=${4:-""}
    local toml_file=$(get_toml_path "$distro")
    
    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$toml_file")"
    
    # Create file with sections if it doesn't exist
    if [ ! -f "$toml_file" ]; then
        case "$distro" in
            arch)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:pacman]

[cli:yay]

[cli:paru]

# Desktop packages
[desktop:pacman]

[desktop:yay]

[desktop:paru]

# Gaming packages
[gaming:pacman]

[gaming:yay]

[gaming:paru]
EOF
                ;;
            debian)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:apt]

# Desktop packages
[desktop:apt]

# Gaming packages
[gaming:apt]
EOF
                ;;
            fedora)
                cat > "$toml_file" <<EOF
# CLI packages
[cli:dnf]

# Desktop packages
[desktop:dnf]

# Gaming packages
[gaming:dnf]
EOF
                ;;
        esac
    fi
    
    # Note: We don't return early if package exists - we need to move it to the correct section
    
    # Determine package category
    local category=$(get_package_category "$package" "$explicit_type")
    
    # If explicit type is provided, manage type files
    if [ -n "$explicit_type" ]; then
        # Remove package from other type files
        remove_package_from_other_types "$explicit_type" "$package"
        
        # Add package to the appropriate type file
        if type_file_exists "$explicit_type"; then
            add_package_to_type_file "$explicit_type" "$package"
        else
            # Type file doesn't exist, add to general.toml
            add_package_to_general_toml "$explicit_type" "$package"
        fi
    else
        # Auto-detect: add to type file if it exists for the detected category
        if type_file_exists "$category"; then
            add_package_to_type_file "$category" "$package"
        fi
    fi
    
    # Remove package from all sections in distro TOML before adding to new section
    # This ensures the package is only in one section
    if package_in_toml "$distro" "$package"; then
        # Remove from all sections first
        local temp_file_remove=$(mktemp)
        while IFS= read -r line || [ -n "$line" ]; do
            local original_line="$line"
            local clean_line="${line%%#*}"
            local package_name=$(echo "$clean_line" | xargs)
            
            # Check if we're entering any section
            if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
                echo "$original_line" >> "$temp_file_remove"
            # Skip the package if it matches (ignoring comments)
            elif [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
                # Don't echo this line (remove it)
                continue
            # Regular line - preserve it (including comments)
            else
                echo "$original_line" >> "$temp_file_remove"
            fi
        done < "$toml_file"
        mv "$temp_file_remove" "$toml_file"
    fi
    
    local target_section="[${category}:${package_manager}]"
    
    # Also check for legacy sections for backward compatibility
    local legacy_section="[${package_manager}]"
    
    local temp_file=$(mktemp)
    local target_section_found=0
    local legacy_section_found=0
    local inserted=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve the original line for comments
        local original_line="$line"
        local clean_line="${line%%#*}"
        clean_line=$(echo "$clean_line" | xargs)
        
        # Check if we're entering the target section (new format)
        if [ "$clean_line" = "$target_section" ]; then
            target_section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering legacy section (backward compatibility)
        elif [ "$clean_line" = "$legacy_section" ]; then
            legacy_section_found=1
            echo "$original_line" >> "$temp_file"
            # Insert package right after section header
            if [ $inserted -eq 0 ]; then
                echo "$package" >> "$temp_file"
                inserted=1
            fi
        # Check if we're entering any other section
        elif [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            echo "$original_line" >> "$temp_file"
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$toml_file"
    
    # If neither section exists, add the new format section at the end
    if [ $inserted -eq 0 ]; then
        echo "" >> "$temp_file"
        echo "$target_section" >> "$temp_file"
        echo "$package" >> "$temp_file"
    fi
    
    mv "$temp_file" "$toml_file"
}

# Update TOML files for all distros if package is common
# Checks if package exists in other distros' package repositories.
# If it exists in multiple distros' repositories, syncs to all relevant TOML files.
update_toml_sync() {
    local current_distro=$1
    local package_manager=$2
    local package=$3
    local explicit_type=${4:-""}
    
    # Update current distro's TOML first
    update_toml "$current_distro" "$package_manager" "$package" "$explicit_type"
    
    # Check and sync to other distros if package exists there
    for other_distro in arch debian fedora; do
        # Skip current distro
        [ "$other_distro" = "$current_distro" ] && continue
        
        # Determine package manager for other distro
        case "$other_distro" in
            arch) other_pm="pacman" ;;
            debian) other_pm="apt" ;;
            fedora) other_pm="dnf" ;;
        esac
        
        # Check if package exists in this distro's repositories
        case "$other_distro" in
            arch)
                if package_exists_arch "$package"; then
                    echo -e "${CYAN}Package $package exists in arch repositories, updating arch.toml...${NC}"
                    update_toml "arch" "$other_pm" "$package" "$explicit_type"
                fi
                ;;
            debian)
                if package_exists_debian "$package"; then
                    echo -e "${CYAN}Package $package exists in debian repositories, updating debian.toml...${NC}"
                    update_toml "debian" "$other_pm" "$package" "$explicit_type"
                fi
                ;;
            fedora)
                if package_exists_fedora "$package"; then
                    echo -e "${CYAN}Package $package exists in fedora repositories, updating fedora.toml...${NC}"
                    update_toml "fedora" "$other_pm" "$package" "$explicit_type"
                fi
                ;;
        esac
    done
}

# Remove package from TOML file (checks all sections, preserves comments)
# Handles both new format [cli:pacman] and legacy format [pacman]
remove_from_toml() {
    local distro=$1
    local package_manager=$2
    local package=$3
    local toml_file=$(get_toml_path "$distro")
    
    if [ ! -f "$toml_file" ]; then
        return 0  # File doesn't exist, nothing to remove
    fi
    
    # Remove package from all sections where it appears
    local temp_file=$(mktemp)
    local in_section=0
    local package_found=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve the original line
        local original_line="$line"
        # Extract package name (remove inline comments and trim)
        local clean_line="${line%%#*}"
        local package_name=$(echo "$clean_line" | xargs)
        
        # Check if we're entering any section
        if [[ "$clean_line" =~ ^\[.*\]$ ]]; then
            in_section=1
            echo "$original_line" >> "$temp_file"
        # We're in a section - skip the package if it matches (ignoring comments)
        elif [ $in_section -eq 1 ] && [ "$package_name" = "$package" ] && [ -n "$package_name" ]; then
            package_found=1
            # Don't echo this line (remove it)
            continue
        # Regular line - preserve it (including comments)
        else
            echo "$original_line" >> "$temp_file"
        fi
    done < "$toml_file"
    
    mv "$temp_file" "$toml_file"
    
    if [ $package_found -eq 1 ]; then
        echo -e "${GREEN}Removed $package from ${distro}.toml${NC}"
    fi
}

# Remove package from TOML files for all distros if package is common
# Checks if package exists in other distros' package repositories.
# If it exists in multiple distros' repositories, removes from all relevant TOML files.
remove_from_toml_sync() {
    local current_distro=$1
    local package_manager=$2
    local package=$3
    
    # Remove from current distro's TOML first
    remove_from_toml "$current_distro" "$package_manager" "$package"
    
    # Check and remove from other distros if package exists there
    for other_distro in arch debian fedora; do
        # Skip current distro
        [ "$other_distro" = "$current_distro" ] && continue
        
        # Determine package manager for other distro
        case "$other_distro" in
            arch) other_pm="pacman" ;;
            debian) other_pm="apt" ;;
            fedora) other_pm="dnf" ;;
        esac
        
        # Check if package exists in this distro's repositories
        case "$other_distro" in
            arch)
                if package_exists_arch "$package"; then
                    echo -e "${CYAN}Package $package exists in arch repositories, removing from arch.toml...${NC}"
                    remove_from_toml "arch" "$other_pm" "$package"
                fi
                ;;
            debian)
                if package_exists_debian "$package"; then
                    echo -e "${CYAN}Package $package exists in debian repositories, removing from debian.toml...${NC}"
                    remove_from_toml "debian" "$other_pm" "$package"
                fi
                ;;
            fedora)
                if package_exists_fedora "$package"; then
                    echo -e "${CYAN}Package $package exists in fedora repositories, removing from fedora.toml...${NC}"
                    remove_from_toml "fedora" "$other_pm" "$package"
                fi
                ;;
        esac
    done
}

# Install package on Arch with specific package manager
install_arch_with_pm() {
    local package=$1
    local package_manager=$2
    
    case "$package_manager" in
        pacman)
            if pacman -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Installing $package via pacman...${NC}"
                if sudo pacman -S --noconfirm "$package"; then
                    return 0
                else
                    echo -e "${RED}Failed to install $package via pacman${NC}"
                    return 1
                fi
            else
                echo -e "${RED}Package $package not found in pacman${NC}"
                return 1
            fi
            ;;
        yay)
            if command -v yay &>/dev/null; then
                if yay -Si "$package" &>/dev/null; then
                    echo -e "${CYAN}Installing $package via yay...${NC}"
                    if yay -S --noconfirm "$package"; then
                        return 0
                    else
                        echo -e "${RED}Failed to install $package via yay${NC}"
                        return 1
                    fi
                else
                    echo -e "${RED}Package $package not found in yay${NC}"
                    return 1
                fi
            else
                echo -e "${RED}yay is not installed${NC}"
                return 1
            fi
            ;;
        paru)
            if command -v paru &>/dev/null; then
                if paru -Si "$package" &>/dev/null; then
                    echo -e "${CYAN}Installing $package via paru...${NC}"
                    if paru -S --noconfirm "$package"; then
                        return 0
                    else
                        echo -e "${RED}Failed to install $package via paru${NC}"
                        return 1
                    fi
                else
                    echo -e "${RED}Package $package not found in paru${NC}"
                    return 1
                fi
            else
                echo -e "${RED}paru is not installed${NC}"
                return 1
            fi
            ;;
        *)
            echo -e "${RED}Unknown package manager: $package_manager${NC}"
            return 1
            ;;
    esac
}

# Install package on Arch (auto-detect package manager)
install_arch() {
    local package=$1
    local explicit_type=${2:-""}
    
    # Show detected type if not explicitly provided
    if [ -z "$explicit_type" ]; then
        local detected_type=$(get_package_category "$package" "")
        echo -e "${CYAN}Detected type: ${detected_type}${NC}"
    fi
    
    # Try pacman first
    if pacman -Si "$package" &>/dev/null; then
        echo -e "${CYAN}Installing $package via pacman...${NC}"
        if sudo pacman -S --noconfirm "$package"; then
            update_toml_sync "arch" "pacman" "$package" "$explicit_type"
            return 0
        else
            echo -e "${RED}Failed to install $package via pacman${NC}"
            return 1
        fi
    fi
    
    # Try yay if available
    if command -v yay &>/dev/null; then
        echo -e "${CYAN}Package not found in pacman, trying yay...${NC}"
        if yay -Si "$package" &>/dev/null; then
            echo -e "${CYAN}Installing $package via yay...${NC}"
            if yay -S --noconfirm "$package"; then
                update_toml_sync "arch" "yay" "$package" "$explicit_type"
                return 0
            else
                echo -e "${RED}Failed to install $package via yay${NC}"
                return 1
            fi
        fi
    fi
    
    # Try paru if available
    if command -v paru &>/dev/null; then
        echo -e "${CYAN}Package not found in yay, trying paru...${NC}"
        if paru -Si "$package" &>/dev/null; then
            echo -e "${CYAN}Installing $package via paru...${NC}"
            if paru -S --noconfirm "$package"; then
                update_toml_sync "arch" "paru" "$package" "$explicit_type"
                return 0
            else
                echo -e "${RED}Failed to install $package via paru${NC}"
                return 1
            fi
        fi
    fi
    
    echo -e "${RED}Package $package not found in pacman or AUR helpers${NC}"
    return 1
}

# Install package on Debian
install_debian() {
    local package=$1
    local explicit_type=${2:-""}
    
    # Show detected type if not explicitly provided
    if [ -z "$explicit_type" ]; then
        local detected_type=$(get_package_category "$package" "")
        echo -e "${CYAN}Detected type: ${detected_type}${NC}"
    fi
    
    echo -e "${CYAN}Installing $package via apt...${NC}"
    sudo apt update
    if sudo apt install -y "$package"; then
        update_toml_sync "debian" "apt" "$package" "$explicit_type"
        return 0
    else
        return 1
    fi
}

# Install package on Fedora
install_fedora() {
    local package=$1
    local explicit_type=${2:-""}
    
    # Show detected type if not explicitly provided
    if [ -z "$explicit_type" ]; then
        local detected_type=$(get_package_category "$package" "")
        echo -e "${CYAN}Detected type: ${detected_type}${NC}"
    fi
    
    echo -e "${CYAN}Installing $package via dnf...${NC}"
    if sudo dnf install -y "$package"; then
        update_toml_sync "fedora" "dnf" "$package" "$explicit_type"
        return 0
    else
        return 1
    fi
}

# Remove package on Arch
remove_arch() {
    local package=$1
    local flags=${2:-"-Rns"}  # Default to -Rns (remove with dependencies and config)
    local package_manager=""
    
    # Try pacman first
    if pacman -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via pacman...${NC}"
        if sudo pacman $flags --noconfirm "$package"; then
            package_manager="pacman"
        else
            return 1
        fi
    # Try yay if available
    elif command -v yay &>/dev/null && yay -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via yay...${NC}"
        if yay $flags --noconfirm "$package"; then
            package_manager="yay"
        else
            return 1
        fi
    # Try paru if available
    elif command -v paru &>/dev/null && paru -Qi "$package" &>/dev/null; then
        echo -e "${CYAN}Removing $package via paru...${NC}"
        if paru $flags --noconfirm "$package"; then
            package_manager="paru"
        else
            return 1
        fi
    else
        echo -e "${RED}Package $package not found or not installed${NC}"
        return 1
    fi
    
    # Remove from TOML if removal was successful
    if [ -n "$package_manager" ]; then
        remove_from_toml_sync "arch" "$package_manager" "$package"
    fi
    
    return 0
}

# Remove package on Debian
remove_debian() {
    local package=$1
    
    echo -e "${CYAN}Removing $package via apt...${NC}"
    if sudo apt remove -y "$package"; then
        # Remove from TOML if removal was successful
        remove_from_toml_sync "debian" "apt" "$package"
        return 0
    else
        return 1
    fi
}

# Remove package on Fedora
remove_fedora() {
    local package=$1
    
    echo -e "${CYAN}Removing $package via dnf...${NC}"
    if sudo dnf remove -y "$package"; then
        # Remove from TOML if removal was successful
        remove_from_toml_sync "fedora" "dnf" "$package"
        return 0
    else
        return 1
    fi
}

# Search packages on Arch
search_arch() {
    local query=$1
    
    echo -e "${CYAN}Searching pacman repositories for: $query${NC}"
    pacman -Ss "$query"
    
    if command -v yay &>/dev/null; then
        echo ""
        echo -e "${CYAN}Searching AUR (yay) for: $query${NC}"
        yay -Ss "$query"
    elif command -v paru &>/dev/null; then
        echo ""
        echo -e "${CYAN}Searching AUR (paru) for: $query${NC}"
        paru -Ss "$query"
    fi
}

# Search packages on Debian
search_debian() {
    local query=$1
    
    echo -e "${CYAN}Searching apt repositories for: $query${NC}"
    apt search "$query"
}

# Search packages on Fedora
search_fedora() {
    local query=$1
    
    echo -e "${CYAN}Searching dnf repositories for: $query${NC}"
    dnf search "$query"
}

# Update package lists and upgrade packages
update_packages() {
    local distro=$(detect_distro)
    
    case "$distro" in
        arch)
            echo -e "${CYAN}Updating package database and upgrading packages...${NC}"
            sudo pacman -Syu --noconfirm
            if command -v yay &>/dev/null; then
                echo ""
                echo -e "${CYAN}Updating AUR packages (yay)...${NC}"
                yay -Syu --noconfirm
            elif command -v paru &>/dev/null; then
                echo ""
                echo -e "${CYAN}Updating AUR packages (paru)...${NC}"
                paru -Syu --noconfirm
            fi
            ;;
        debian)
            echo -e "${CYAN}Updating package lists and upgrading packages...${NC}"
            sudo apt update && sudo apt upgrade -y
            ;;
        fedora)
            echo -e "${CYAN}Updating package database and upgrading packages...${NC}"
            sudo dnf update -y
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# Show package info
info_package() {
    local package=$1
    local distro=$(detect_distro)
    
    case "$distro" in
        arch)
            if pacman -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from pacman:${NC}"
                pacman -Si "$package"
            elif command -v yay &>/dev/null && yay -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from AUR (yay):${NC}"
                yay -Si "$package"
            elif command -v paru &>/dev/null && paru -Si "$package" &>/dev/null; then
                echo -e "${CYAN}Package info from AUR (paru):${NC}"
                paru -Si "$package"
            else
                echo -e "${RED}Package $package not found${NC}"
                return 1
            fi
            ;;
        debian)
            echo -e "${CYAN}Package info:${NC}"
            apt show "$package" 2>/dev/null || apt-cache show "$package" 2>/dev/null
            ;;
        fedora)
            echo -e "${CYAN}Package info:${NC}"
            dnf info "$package"
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# List installed packages
list_installed() {
    local distro=$(detect_distro)
    local query=${1:-""}
    
    case "$distro" in
        arch)
            if [ -n "$query" ]; then
                pacman -Q | grep -i "$query"
            else
                pacman -Q
            fi
            ;;
        debian)
            if [ -n "$query" ]; then
                dpkg -l | grep -i "$query"
            else
                dpkg -l
            fi
            ;;
        fedora)
            if [ -n "$query" ]; then
                dnf list installed | grep -i "$query"
            else
                dnf list installed
            fi
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            return 1
            ;;
    esac
}

# Determine package category
# Returns: "gaming", "cli", "desktop", or custom type
# If explicit_type is provided, use that instead of checking type files
get_package_category() {
    local package=$1
    local explicit_type=${2:-""}
    
    # If explicit type is provided, use it
    if [ -n "$explicit_type" ]; then
        echo "$explicit_type"
        return 0
    fi
    
    # Check type files in order: gaming, cli, then check general.toml
    if package_in_type_file "gaming" "$package"; then
        echo "gaming"
        return 0
    fi
    
    if package_in_type_file "cli" "$package"; then
        echo "cli"
        return 0
    fi
    
    # Check general.toml for other types
    local general_file="$TYPES_DIR/general.toml"
    if [ -f "$general_file" ]; then
        local current_section=""
        while IFS= read -r line || [ -n "$line" ]; do
            local clean_line="${line%%#*}"
            clean_line=$(echo "$clean_line" | xargs)
            
            # Check if it's a section header
            if [[ "$clean_line" =~ ^\[(.*)\]$ ]]; then
                current_section="${BASH_REMATCH[1]}"
            # Check if package matches
            elif [ "$clean_line" = "$package" ] && [ -n "$current_section" ]; then
                echo "$current_section"
                return 0
            fi
        done < "$general_file"
    fi
    
    # Default to desktop if not found in any type file
    echo "desktop"
}

# Parse TOML file and extract packages by section
# Supports both old format [pacman] and new format [cli:pacman], [desktop:pacman], [gaming:pacman]
# If cli_only is true, filters out desktop and gaming packages
# If gaming_only is true, filters out CLI and desktop packages
parse_toml_packages() {
    local toml_file=$1
    local cli_only=${2:-false}
    local gaming_only=${3:-false}
    local section=""
    declare -A packages_by_section
    
    if [ ! -f "$toml_file" ]; then
        echo -e "${RED}TOML file not found: $toml_file${NC}"
        return 1
    fi
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Preserve original line for comments
        local original_line="$line"
        
        # Remove inline comments (everything after #)
        local package_line="${line%%#*}"
        # Remove leading/trailing whitespace
        package_line=$(echo "$package_line" | xargs)
        
        # Skip empty lines and comment-only lines
        [ -z "$package_line" ] && continue
        
        # Check if it's a section header
        if [[ "$package_line" =~ ^\[.*\] ]]; then
            section="${package_line//[\[\]]/}"
            section=$(echo "$section" | xargs)
            packages_by_section["$section"]=""
        # It's a package name (non-empty line that's not a section header)
        elif [ -n "$section" ] && [ -n "$package_line" ]; then
            # Determine section category
            local is_desktop_section=false
            local is_gaming_section=false
            local is_cli_section=false
            
            # Check section format: [cli:pacman], [desktop:pacman], [gaming:pacman], or legacy [pacman]
            if [[ "$section" =~ ^desktop: ]]; then
                is_desktop_section=true
            elif [[ "$section" =~ ^gaming: ]]; then
                is_gaming_section=true
            elif [[ "$section" =~ ^cli: ]]; then
                is_cli_section=true
            elif [[ ! "$section" =~ : ]]; then
                # Legacy format [pacman] - determine category from package name
                local category=$(get_package_category "$package_line")
                if [ "$category" = "desktop" ]; then
                    is_desktop_section=true
                elif [ "$category" = "gaming" ]; then
                    is_gaming_section=true
                elif [ "$category" = "cli" ]; then
                    is_cli_section=true
                fi
            fi
            
            # Skip packages based on filter flags
            if [ "$cli_only" = true ] && ([ "$is_desktop_section" = true ] || [ "$is_gaming_section" = true ]); then
                continue
            fi
            
            if [ "$gaming_only" = true ] && ([ "$is_desktop_section" = true ] || [ "$is_cli_section" = true ]); then
                continue
            fi
            
            if [ -z "${packages_by_section[$section]}" ]; then
                packages_by_section["$section"]="$package_line"
            else
                packages_by_section["$section"]="${packages_by_section[$section]} $package_line"
            fi
        fi
    done < "$toml_file"
    
    # Output packages by section
    # For new format [cli:pacman], extract package manager for installation
    # Group packages by package manager (combining cli and desktop sections)
    declare -A packages_by_pm
    
    for section in "${!packages_by_section[@]}"; do
        local pm_name="$section"
        # Extract package manager from section name
        if [[ "$section" =~ : ]]; then
            # New format: [cli:pacman], [desktop:pacman], or [gaming:pacman] -> extract "pacman"
            pm_name="${section#*:}"
        fi
        # Combine packages from cli, desktop, and gaming sections for same PM
        if [ -z "${packages_by_pm[$pm_name]}" ]; then
            packages_by_pm["$pm_name"]="${packages_by_section[$section]}"
        else
            packages_by_pm["$pm_name"]="${packages_by_pm[$pm_name]} ${packages_by_section[$section]}"
        fi
    done
    
    # Output packages grouped by package manager
    for pm_name in "${!packages_by_pm[@]}"; do
        echo "${pm_name}:${packages_by_pm[$pm_name]}"
    done
}

# Install all packages from TOML file
install_all_from_toml() {
    local cli_only=${1:-false}
    local gaming_only=${2:-false}
    local distro=$(detect_distro)
    local toml_file=$(get_toml_path "$distro")
    local failed_packages_file=$(mktemp)
    
    if [ ! -f "$toml_file" ]; then
        echo -e "${RED}TOML file not found: $toml_file${NC}"
        echo -e "${YELLOW}Run '$0 <package-name>' to install packages first${NC}"
        return 1
    fi
    
    if [ "$gaming_only" = true ]; then
        echo -e "${CYAN}Installing gaming-only packages from $toml_file (skipping CLI and desktop packages)...${NC}"
    elif [ "$cli_only" = true ]; then
        echo -e "${CYAN}Installing CLI-only packages from $toml_file (skipping desktop and gaming packages)...${NC}"
    else
        echo -e "${CYAN}Installing all packages from $toml_file...${NC}"
    fi
    echo ""
    
    local parsed_packages
    
    # Parse TOML file (with cli_only/gaming_only filter if enabled)
    # Default behavior: on non-Arch distros, skip desktop and gaming packages by default
    # On Arch, install all packages unless --cli-only or --gaming-only is specified
    local filter_cli=false
    local filter_gaming=false
    if [ "$gaming_only" = true ]; then
        filter_gaming=true
    elif [ "$cli_only" = true ]; then
        filter_cli=true
    elif [ "$distro" != "arch" ]; then
        # On non-Arch distros, default to CLI-only (skip desktop and gaming packages)
        filter_cli=true
        filter_gaming=true
        echo -e "${YELLOW}Note: Skipping desktop and gaming packages on $distro by default.${NC}"
        echo -e "${YELLOW}Desktop and gaming packages are only installed on Arch Linux.${NC}"
        echo ""
    fi
    
    parsed_packages=$(parse_toml_packages "$toml_file" "$filter_cli" "$filter_gaming")
    
    case "$distro" in
        arch)
            # Install pacman packages first
            local pacman_pkgs=$(echo "$parsed_packages" | grep "^pacman:" | cut -d: -f2-)
            if [ -n "$pacman_pkgs" ]; then
                echo -e "${CYAN}=== Installing pacman packages ===${NC}"
                for package in $pacman_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "pacman"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            
            # Install yay packages
            local yay_pkgs=$(echo "$parsed_packages" | grep "^yay:" | cut -d: -f2-)
            if [ -n "$yay_pkgs" ] && command -v yay &>/dev/null; then
                echo ""
                echo -e "${CYAN}=== Installing yay packages ===${NC}"
                for package in $yay_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "yay"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            elif [ -n "$yay_pkgs" ]; then
                echo ""
                echo -e "${YELLOW}Warning: yay packages found but yay is not installed. Skipping yay packages.${NC}"
            fi
            
            # Install paru packages
            local paru_pkgs=$(echo "$parsed_packages" | grep "^paru:" | cut -d: -f2-)
            if [ -n "$paru_pkgs" ] && command -v paru &>/dev/null; then
                echo ""
                echo -e "${CYAN}=== Installing paru packages ===${NC}"
                for package in $paru_pkgs; do
                    [ -z "$package" ] && continue
                    if ! install_arch_with_pm "$package" "paru"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            elif [ -n "$paru_pkgs" ]; then
                echo ""
                echo -e "${YELLOW}Warning: paru packages found but paru is not installed. Skipping paru packages.${NC}"
            fi
            ;;
        debian)
            # Install apt packages
            local apt_pkgs=$(echo "$parsed_packages" | grep "^apt:" | cut -d: -f2-)
            if [ -n "$apt_pkgs" ]; then
                echo -e "${CYAN}=== Installing apt packages ===${NC}"
                echo -e "${CYAN}Updating package lists...${NC}"
                sudo apt update
                for package in $apt_pkgs; do
                    [ -z "$package" ] && continue
                    echo -e "${CYAN}Installing $package via apt...${NC}"
                    if ! sudo apt install -y "$package"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            ;;
        fedora)
            # Install dnf packages
            local dnf_pkgs=$(echo "$parsed_packages" | grep "^dnf:" | cut -d: -f2-)
            if [ -n "$dnf_pkgs" ]; then
                echo -e "${CYAN}=== Installing dnf packages ===${NC}"
                for package in $dnf_pkgs; do
                    [ -z "$package" ] && continue
                    echo -e "${CYAN}Installing $package via dnf...${NC}"
                    if ! sudo dnf install -y "$package"; then
                        echo "$package" >> "$failed_packages_file"
                    fi
                done
            fi
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            rm -f "$failed_packages_file"
            return 1
            ;;
    esac
    
    echo ""
    if [ -s "$failed_packages_file" ]; then
        local failed_list=$(cat "$failed_packages_file" | tr '\n' ' ')
        echo -e "${YELLOW}Warning: The following packages failed to install: ${failed_list}${NC}"
        rm -f "$failed_packages_file"
        return 1
    else
        echo -e "${GREEN}All packages installed successfully!${NC}"
        rm -f "$failed_packages_file"
        return 0
    fi
}

# Main install function
install_package() {
    local package=$1
    local explicit_type=${2:-""}
    local distro=$(detect_distro)
    
    if [ -z "$package" ]; then
        echo -e "${RED}Usage: $0 <package-name>${NC}"
        exit 1
    fi
    
    case "$distro" in
        arch)
            install_arch "$package" "$explicit_type"
            ;;
        debian)
            install_debian "$package" "$explicit_type"
            ;;
        fedora)
            install_fedora "$package" "$explicit_type"
            ;;
        *)
            echo -e "${RED}Unsupported distribution: $distro${NC}"
            exit 1
            ;;
    esac
}

# Parse command/operation from arguments
parse_operation() {
    local first_arg=$1
    
    # Handle special flags and commands
    case "$first_arg" in
        --all|-a)
            echo "install_all"
            return 0
            ;;
        -R|-Rns|--remove|remove|uninstall)
            echo "remove"
            return 0
            ;;
        -Ss|--search|search)
            echo "search"
            return 0
            ;;
        -Syu|-Sy|--update|update|upgrade)
            echo "update"
            return 0
            ;;
        -Si|--info|info)
            echo "info"
            return 0
            ;;
        -Q|-Qe|-Qm|--list|list)
            echo "list"
            return 0
            ;;
        -S|--install|install)
            echo "install"
            return 0
            ;;
    esac
    
    # Check for pacman-style flags (Arch)
    if [[ "$first_arg" =~ ^-R ]]; then
        echo "remove"
        return 0
    fi
    
    if [[ "$first_arg" =~ ^-Q ]]; then
        echo "list"
        return 0
    fi
    
    # Default to install (package name provided directly)
    echo "install"
}

# Main argument parsing
if [ $# -eq 0 ]; then
    echo -e "${CYAN}Package Manager Wrapper${NC}"
    echo ""
    echo -e "${CYAN}Usage:${NC}"
    echo "  $0 [operation] [packages...]"
    echo ""
    echo -e "${CYAN}Operations:${NC}"
    echo "  install, -S          Install packages (default)"
    echo "  --all, -a             Install all packages from TOML file"
    echo "  --cli-only            Install only CLI packages (skip desktop and gaming packages)"
    echo "                        On non-Arch distros, this is the default behavior"
    echo "  --gaming-only         Install only gaming packages (skip CLI and desktop packages)"
    echo "  --type=TYPE, -t TYPE  Specify package type explicitly (e.g., --type=gaming, -t utils)"
    echo "                        Works regardless of position in command line"
    echo "                        If type file doesn't exist, creates/updates general.toml"
    echo "                        Removes package from other type files if it exists"
    echo "  remove, -R, -Rns      Remove packages"
    echo "  search, -Ss           Search for packages"
    echo "  update, -Syu, upgrade Update package lists and upgrade"
    echo "  info, -Si             Show package information"
    echo "  list, -Q              List installed packages"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  $0 --all                    # Install all packages from TOML"
    echo "  $0 --all --cli-only         # Install only CLI packages (skip desktop and gaming)"
    echo "  $0 --all --gaming-only      # Install only gaming packages (skip CLI and desktop)"
    echo "  $0 --type=gaming steam      # Install steam as gaming package"
    echo "  $0 install greenclip -t utils  # Install greenclip as utils (creates general.toml)"
    echo "  $0 -t utils greenclip       # Short form, works in any position"
    echo "  $0 kitty tmux zsh           # Install packages (default)"
    echo "  $0 -S kitty                 # Install package (explicit)"
    echo "  $0 -Rns chromium            # Remove package (Arch: pacman style)"
    echo "  $0 remove kitty             # Remove package (Debian: apt style)"
    echo "  $0 -R chromium              # Remove package (Arch: simple)"
    echo "  $0 -Ss neovim               # Search for packages (Arch)"
    echo "  $0 search neovim            # Search for packages (Debian)"
    echo "  $0 -Syu                     # Update and upgrade (Arch)"
    echo "  $0 update                   # Update and upgrade (Debian)"
    echo "  $0 -Si chromium             # Show package info (Arch)"
    echo "  $0 info chromium            # Show package info (Debian)"
    echo "  $0 -Q                       # List installed packages (Arch)"
    echo "  $0 list                     # List installed packages (Debian)"
    exit 1
fi

# Check for --cli-only, --gaming-only, and --type/-t flags and remove them from arguments
# This works regardless of position in the command line
cli_only=false
gaming_only=false
explicit_type=""
args=()
skip_next=false

# Convert arguments to array for easier iteration
declare -a all_args=("$@")

for i in "${!all_args[@]}"; do
    arg="${all_args[$i]}"
    # Get next argument if it exists
    if [ $((i+1)) -lt ${#all_args[@]} ]; then
        next_arg="${all_args[$((i+1))]}"
    else
        next_arg=""
    fi
    
    # Skip if we're processing the value after -t
    if [ "$skip_next" = true ]; then
        skip_next=false
        continue
    fi
    
    if [ "$arg" = "--cli-only" ]; then
        cli_only=true
    elif [ "$arg" = "--gaming-only" ]; then
        gaming_only=true
    elif [[ "$arg" =~ ^--type= ]]; then
        explicit_type="${arg#--type=}"
    elif [[ "$arg" =~ ^-t= ]]; then
        explicit_type="${arg#-t=}"
    elif [ "$arg" = "-t" ] && [ -n "$next_arg" ]; then
        # Handle -t as separate argument (next arg is the type)
        explicit_type="$next_arg"
        skip_next=true
    else
        args+=("$arg")
    fi
done

set -- "${args[@]}"

operation=$(parse_operation "$1")

# Handle operations
case "$operation" in
    install_all)
        install_all_from_toml "$cli_only" "$gaming_only"
        exit $?
        ;;
    remove)
        # Extract removal flags if present
        remove_flags="-Rns"
        if [[ "$1" =~ ^-R ]]; then
            remove_flags="$1"
            shift
        elif [[ "$1" =~ ^(--remove|remove|uninstall)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No packages specified for removal${NC}"
            exit 1
        fi
        
        distro=$(detect_distro)
        failed_packages=()
        for package in "$@"; do
            case "$distro" in
                arch)
                    if ! remove_arch "$package" "$remove_flags"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                debian)
                    if ! remove_debian "$package"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                fedora)
                    if ! remove_fedora "$package"; then
                        failed_packages+=("$package")
                    fi
                    ;;
                *)
                    echo -e "${RED}Unsupported distribution: $distro${NC}"
                    exit 1
                    ;;
            esac
        done
        
        if [ ${#failed_packages[@]} -gt 0 ]; then
            echo -e "${YELLOW}Warning: Failed to remove: ${failed_packages[*]}${NC}"
            exit 1
        fi
        ;;
    search)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Ss|--search|search)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No search query specified${NC}"
            exit 1
        fi
        
        distro=$(detect_distro)
        for query in "$@"; do
            case "$distro" in
                arch)
                    search_arch "$query"
                    ;;
                debian)
                    search_debian "$query"
                    ;;
                fedora)
                    search_fedora "$query"
                    ;;
                *)
                    echo -e "${RED}Unsupported distribution: $distro${NC}"
                    exit 1
                    ;;
            esac
        done
        ;;
    update)
        update_packages
        exit $?
        ;;
    info)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Si|--info|info)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No package specified${NC}"
            exit 1
        fi
        
        for package in "$@"; do
            info_package "$package"
            echo ""
        done
        ;;
    list)
        # Check if first arg is the operation flag/command
        if [[ "$1" =~ ^(-Q|-Qe|-Qm|--list|list)$ ]]; then
            shift
        fi
        list_installed "$@"
        ;;
    install)
        # Check if first arg is the operation flag/command and remove it
        if [[ "$1" =~ ^(-S|--install|install)$ ]]; then
            shift
        fi
        
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: No packages specified${NC}"
            exit 1
        fi
        
        failed_packages=()
        for package in "$@"; do
            if ! install_package "$package" "$explicit_type"; then
                failed_packages+=("$package")
            fi
        done
        
        if [ ${#failed_packages[@]} -gt 0 ]; then
            echo -e "${RED}Error: The following packages failed to install: ${failed_packages[*]}${NC}"
            exit 1
        fi
        
        echo -e "${GREEN}All packages installed successfully!${NC}"
        ;;
    *)
        echo -e "${RED}Unknown operation: $operation${NC}"
        exit 1
        ;;
esac

